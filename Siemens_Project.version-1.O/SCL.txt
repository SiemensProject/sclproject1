////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright   (C) Siemens AG 1995-2018. All Rights Reserved. Confidential
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Short description: PID Control Large
//
//  A PID controller function block is used to drive a measured value PV from any technical process
//  to a given setpoint SP, by calculating appropriate values for a related manipulated variable MV.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//Author:  A&D AS RD DH K3  Mohr                                Datum:  08.01.2008        Vers.: 1.0
//Change:  First version
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  08.04.09          Vers.: 1.1
//?nderung APL V7.1.2:  RQ AP00811937: OptimEn in Status1 bei Reglerbausteinen
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  05.05.09          Vers.: 1.1
//?nderung APL V7.1.2:  EU_APL_V7.1.2_Signalwert_bei_Grenzwertverletzung
//                      EU_APL_V7.1.2_Deaktivierung_von_schaltpunkten
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  18.06.09          Vers.: 1.1
//?nderung:  AP00834553 Rampenfunktion im OB32 fehlerhaft mit Default-Werten
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  09.07.09          Vers.: 1.1
//?nderung:  AP00848084 Feature-Bit 29 (Signalwert bei Grenwertverletzung) verursacht Meldungen.
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  14.07.09          Vers.: 1.1
//?nderung:  AP00849676 Umschaltung f?r "Signalwert bei Grenzwertverletzung" fehlerhaft
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  06.10.09          Vers.: 1.1
//?nderung:  AP00881277 Verlassen von "Au?er Betrieb" nicht m?glich, wenn Berechtigung f?r Hand erteilt
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  19.10.09          Vers.: 1.1
//?nderung:  AP00885057 Umschaltung von "Automatik" ?ber "Hand" nach "Out of Service" noch fehlerhaft!
//
//------------------------------------ APL V7.1.4 --------------------------------------------------------
//Ge?ndert:  I IA AS RD DH K 2, Maier, Klaus                    Datum:  03.12.09          Vers.: 1.2
//?nderung:  EU_Ausgangssignal_F?r_Schaltbereit
//
//Ge?ndert:  I IA AS RD DH K 2, Paul Vomacka                    Datum:  17.12.09          Vers.: 1.2
//?nderung:  EU_APL_V7.1.4_Oertliche_Bedienberechtigung
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  07.01.10          Vers.: 1.2
//?nderung:  AP00908941 Bayer: aktive Meldungen von APL-Bausteinen fehlen nach CPU-Stop
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  08.01.10          Vers.: 1.2
//?nderung:  AP00829652 Parameterkommentar zu Parameter MsgLock
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  16.02.10          Vers.: 1.2
//?nderung:  AP00881966 Diskrepanz bei Simulation zwischen OH und Bausteine
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  01.03.10          Vers.: 1.2
//?nderung:  AP00922674 Gradient kann ung?ltige REAL-Zahl erzeugen
//
//Ge?ndert:  I IA AS RD DS K  , Schenawa, Krystian              Datum:  21.04.10          Vers.: 1.2
//?nderung:  AP00944892 APL Baustein PIDConL: MV_TrkOn setzt AutAct auf 0
//
//Ge?ndert:  I IA AS RD DS K  , Schenawa, Krystian              Datum:  26.04.10          Vers.: 1.2
//?nderung:  Initialisierung interner Variablen
//
//Ge?ndert:  I IA AS RD DS K  , Schenawa, Krystian              Datum:  04.05.10          Vers.: 1.2
//?nderung:  AP00948885 Kommentare der einzelnen Featurebits
//
//Ge?ndert:  I IA AS RD DS K  , Krystian Schenawa               Datum:  05.05.10          Vers.: 1.2
//?nderung:  AP00966535 Attribut S7_contact f?r die Parameter GrpErr, RdyToStart und RdyToReset
//
//Ge?ndert:  I IA AS RD DS K  , Krystian Schenawa               Datum:  20.05.10          Vers.: 1.2
//?nderung:  AP00971784 Menge der gemappten Variablen stimmt nicht mit verwendeten Variablen ?berein
//
//
//------------------------------------ APL V7.1.5 --------------------------------------------------------
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  22.06.10          Vers.: 1.3
//?nderung:  EU_APL_V7.1.5_Meldungsunterdr?ckung
//
//Ge?ndert:  I IA AS RD DS K  , Krystian Schenawa               Datum:  15.07.10          Vers.: 1.3
//?nderung:  AP00989674 Block Title: "Large" bzw. "Small" gro?schreiben
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  20.07.10          Vers.: 1.3
//?nderung:  AP00996987 Meldungsbearbeitung trotz Betriebsart "Au?er Betrieb"
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  19.08.10          Vers.: 1.3
//?nderung:  AP00810960 In der Betriebsart 'Ausser Betrieb' sind anstehende Meldungen teilweise sichtbar
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  01.09.10          Vers.: 1.3
//?nderung:  AP01016324 Verhalten von Bausteinausg?ngen in OoS
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  16.09.10          Vers.: 1.3
//?nderung:  AP01016324 Verhalten von Bausteinausg?ngen in OoS
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  17.09.10          Vers.: 1.3
//?nderung:  AP01030619 APL Limit Block don't Propagate Quality to "OutLoAct"and "OutHiAct"
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  27.09.10          Vers.: 1.3
//?nderung:  AP01027071 PIDConR does not work in integral only mode
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  22.10.10          Vers.: 1.3
//?nderung:  AP01037341 F-Technik - Problem mit korrekten ?bersetzungen
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  08.11.10          Vers.: 1.3
//?nderung:  AP01037341 F-Technik - Problem mit korrekten ?bersetzungen
//
//------------------------------------ APL V8.0 --------------------------------------------------------
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  07.02.11          Vers.: 1.4
//?nderung:  EU_APL_V8.0_EventTS_Interface
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  07.02.11          Vers.: 1.4
//?nderung:  EU_APL_V8.0_ZeitbasisRampenGradienten
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  09.02.11          Vers.: 1.4
//?nderung:  EU_APL_V8.0_Schaltpunkte_im_OOS
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  10.02.11          Vers.: 1.4
//?nderung:  EU_APL_V8.0_AenderungS7LinkFalse
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  01.04.11          Vers.: 1.4
//?nderung:  EU_APL_V8.0_Simulation_einschalten
//
//Ge?ndert:  I IA AS RD DH K 2, Maier, Alexander                Datum:  06.04.11          Vers.: 2.0
//?nderung:  AP01163463: Versionsnummer sind nicht richtig: Version hochgez?hlt auf 2.0
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  15.04.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_ZeitbasisRampenGradienten
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  21.04.11          Vers.: 2.0
//?nderung:  AP01115285 externe Simulation beeinflusst Statusbildung abh?ngiger Ausgangsparameter
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  26.04.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_Simulation_einschalten
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  29.04.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_Simulation_Anzeige_des_realen_PV_in_Vorschausicht
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  02.05.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_Erweiterung_ExterneRegeldifferenz
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  03.05.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_Verz?gerung_Alarm_Regelabweichung
//
//Ge?ndert:  I IA AS RD DH KHE 2, Blaser, Albrecht              Datum:  05.05.2011        Vers.: 2.0
//?nderung:  AP01168170: S7_xedit = para f?r Featureparameter entfernt
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  11.05.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_Simulation_einschalten, neue OS_Perm-Bits wieder entfernt
//
//Ge?ndert:  I IA AS RD DH KHE 2, Blaser, Albrecht              Datum:  11.05.2011        Vers.: 2.0
//?nderung:  AP00999485: Vereinheitlichung der Parameter(namen) MsgEvID
//
//Ge?ndert:  I IA AS RD DH KHE 2, Blaser, Albrecht              Datum:  13.05.2011        Vers.: 2.0
//?nderung:  Implementierung EU Bedienberechtigung (Op_Level)
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  17.05.2011        Vers.: 2.0
//?nderung:  EU_APL_V8.0_Rampenfunktion_Darstellung_aktive_Gradientenbegrenzung
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  18.05.2011        Vers.: 2.0
//?nderung:  AP01157631 Signalstatus bilden f?r FmCont und FmTemp
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  20.05.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_Verz?gerung_Alarm_Regelabweichung
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  26.05.2011        Vers.: 2.0
//?nderung:  EU_APL_V8.0_Rampenfunktion_Darstellung_aktive_Gradientenbegrenzung
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  31.05.11          Vers.: 2.0
//?nderung:  EU_APL_V8.0_Erweiterung_ExterneRegeldifferenz
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  14.07.11          Vers.: 2.0
//?nderung:  AP01210017 SimOn goes to 1 if the SimLiOp=1 and the SimOnLi=1
//
//Ge?ndert:  I IA AS RD DH KHE 2, Blaser, Albrecht              Datum:  20.07.2011        Vers.: 2.0
//?nderung:  AP01061441: Sperren der OS-Bedienungen im OB100
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  21.07.11          Vers.: 2.0
//?nderung:  AP01067742 MotL: Motor protection appears on the Faceplate in Oos mode
//
//Ge?ndert:  I IA AS RD DH KHE 2, Blaser, Albrecht              Datum:  25.07.2011        Vers.: 2.0
//?nderung:  AP01214785: Reservebytes reduzieren, verbrauchte Resevebytes freigeben
//
//Ge?ndert:  I IA AS RD DH KHE 2, Mohr, Dieter                  Datum:  02.08.2011        Vers.: 2.0
//?nderung:  AP01061441: Sperren der OS-Bedienungen im OB100
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  04.08.11          Vers.: 2.0
//?nderung:  AP01219813 The mode text on faceplate that all of control blocks appear ???
//?nderung:  AP01067742 MotL: Motor protection appears on the Faceplate in Oos mode
//
//Ge?ndert:  I IA AS RD DH KHE 2, Blaser, Albrecht              Datum:  18.08.2011        Vers.: 2.0
//?nderung:  AP01223409: ManModLi nicht in Block Contact Parametern
//
//Ge?ndert:  I IA AS RD DH KHE 2, Blaser, Albrecht              Datum:  01.09.2011        Vers.: 2.0
//?nderung:  zus?tzlicher Featurebiteingang
//
//Ge?ndert:  I IA AS RD DH KHE 2, Mohr, Dieter                  Datum:  05.09.2011        Vers.: 2.0
//?nderung:  AP01067742: MotL: Motor protection appears on the Faceplate in Oos mode
//
//Ge?ndert:  I IA AS RD DH KHE 2, Mohr, Dieter                  Datum:  27.09.2011        Vers.: 2.0
//?nderung:  AP01246867: Ber?cksichtigung Feature bit 29 bei Bildung von SumMsgAct.Value
//
//Ge?ndert:  I IA AS RD DH KHE 2, Mohr, Dieter                  Datum:  17.11.2011        Vers.: 2.0
//?nderung:  Reserve Eingaenge IntSel, DiffSel
//
//Ge?ndert:  I IA AS RD DH KHE 2, Mohr, Dieter                  Datum:  07.11.2011        Vers.: 2.0
//?nderung:  AP01270847 PIDConL,PIDConR,PIDStepL: Time delay for outgoing ER alarms is not working
//
//Ge?ndert:  I IA AS RD DH KHE 2, Mohr, Dieter                  Datum:  08.11.2011        Vers.: 2.0
//?nderung:  AP01223409: ManModLi nicht in Block Contact Parametern
//
//------------------------------------ APL V8.0.1 --------------------------------------------------------
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  14.03.12          Vers.: 2.1
//?nderung:  EU_APL_V8.0.1_PIDConL_ErweiterungRegelzone
//
//Ge?ndert:  I IA AS RD DH K 2, Mohr, Dieter                    Datum:  09.05.12          Vers.: 2.1
//?nderung:  EU_APL_V8.0.1_PIDConL_ErweiterungRegelzone
//           AP01354937 Beim FeatrureBit12 die doppelte Genauigkeit des Integriertes
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  11.07.2012        Vers.: 2.1
//?nderung:  AP01305384: Uneinheitliche Templatenamen und Verbesseungen zum Templatedesign
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  18.07.2012        Vers.: 2.1
//?nderung:  AP01386491: Negative Werte von DeadBand und ConZone
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  06.08.2012        Vers.: 2.1
//?nderung:  AP01305384: Uneinheitliche Templatenamen und Verbesseungen zum Templatedesign
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  14.08.2012        Vers.: 2.1
//?nderung:  AP01258061: Fester Arbeitspunkt f?r PidConL
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  27.08.2012        Vers.: 2.1
//?nderung:  AP01408289 ?berarbeitung der UDAs S7_(x)edit
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  29.08.2012        Vers.: 2.1
//?nderung:  AP01410396 CHS: Question marks are in some message texts in the Interface comments
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  24.10.2012        Vers.: 2.1
//?nderung:  AP01440414 CR: Verschaltbarkeit vom "AdvCoMV"Eingang am PIDConL-Baustein
//
//------------------------------------ APL V8.0.2 --------------------------------------------------------
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  22.04.13          Vers.: 2.2
//?nderung:  AP01493621 Der Button "Out of Service" ist beim Regler anw?hlbar
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  23.04.2013        Vers.: 2.2
//?nderung:  AP01510222 Umschaltung von Automatik-Extern nach Programmbetrieb nicht verhindern
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  07.06.2013        Vers.: 2.2
//?nderung:  AP01510222 Umschaltung von Automatik-Extern nach Programmbetrieb nicht verhindern
//
//------------------------------------ APL V8.1 --------------------------------------------------------
//Ge?ndert:  CT DC AA I HMI, Aggarwal,Hariom                    Datum:  18.06.2013        Vers.: 3.0
//?nderung:  EU_APL_V8.1_Limit Suppress for each message_R-00048504-8224_V080
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  09.07.2013        Vers.: 3.0
//?nderung:  EU_APL_V8.1_(PIDConL & PIDConR) Display Text Mode and Setpoint_R-00048504-8303
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  26.07.2013        Vers.: 3.0
//?nderung:  EU_APL_V8.1_(PIDConL&PIDConR)_Dynamicly_adapted_dead_band_R-00048504-8234
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  26.07.2013        Vers.: 3.0
//?nderung:  EU_APL_V8.1_Channel_Out_Status_Feedback_into_technological_block_faceplate_R-00048504-8262
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  30.08.2013        Vers.: 3.0
//?nderung:  TFS ID 45714 SimOn goes to 1 if the SimLiOp=1 and the SimOnLi=1
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  12.09.2013        Vers.: 3.0
//?nderung:  EU_APL_V8.1_(PIDConL&PIDConR)_R-00048504-8277
//
//Ge?ndert:  CT DC AA I HMI, Gomasta Abha                       Datum:  06.09.2013        Vers.: 3.0
//?nderung:  EU_APL_V8.1_Active Limit delay times_R-00048504-8257_V04
//
//Ge?ndert:  CT DC AA I HMI, Gomasta Abha                       Datum:  11.09.2013        Vers.: 3.0
//?nderung:  EU_APL_V8.1_Event16Ts(NewFB)_R-00048504-8241
//
//Ge?ndert:  CT DC AA I HMI, Gomasta Abha                       Datum:  10.10.2013        Vers.: 3.0
//?nderung:  Request832111_R-00048504-8257_: When messages are suppressed from WinCC faceplate,
//           "Active limit delay time" indication still shows in faceplate overview (header).
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  11.10.2013        Vers.: 3.0
//?nderung:  740298 PIDConX : Comment for F.Bit 30 isn't matching according to the design document "EU_APL_V8.1_(PIDConL&PIDConR)_adapt_dead_band_R-00048504-8234_V100.doc"
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  11.10.2013        Vers.: 3.0
//?nderung:  740254 Channel out signal status must be considered when calculating ST_Worst
//
//Ge?ndert:  I IA AS PA R&D WF 5, Mohr, Dieter                  Datum:  21.10.2013        Vers.: 3.0
//?nderung:  45720 Fester Arbeitspunkt f?r PidConL (D-Anteil)
//
//Ge?ndert:  CT DC AA I HMI, Aggarwal,Hariom                    Datum:  28.10.2013        Vers.: 3.0
//?nderung:  TFS:45681 NegGain at controller blocks does not work correctly
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  14.11.2013        Vers.: 3.0
//?nderung:  45744 Au?er BetriebModus des Bausteins EventTs kann nicht verlassen werden
//
//Ge?ndert:  I IA AS PA R&D DH 5, Mohr, Dieter                  Datum:  20.11.2013        Vers.: 3.0
//?nderung:  45713 Anzeige Quality Code im Faceplate bei OOS
//
//Ge?ndert:  CT DC AA I HMI, Aggarwal,Hariom                    Datum:  04.12.2013        Vers.: 3.0
//?nderung:  535590: PIDConx : If Internal setpoint value is not within the limits , 
//           THEN last valid setpoint value is NOT displayed in preview view 
//
//Ge?ndert:  CT DC AA I HMI, K,Apoorva                          Datum:  04.12.2013        Vers.: 3.0
//?nderung:  905883: Comment of NegGain Input Pin of PIDConL is wrong
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  11.12.2013        Vers.: 3.0
//?nderung:  945229 PID controller program mode with MV target should not signal ManAct=true
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  16.12.2013        Vers.: 3.0
//?nderung:  905883: Comment of NegGain Input Pin of PIDConL is wrong
//
//Ge?ndert:  CT DC AA I HMI, Aggarwal,Hariom                    Datum:  24.01.2014        Vers.: 3.0
//?nderung:  959690: PIDConL : Behaviour of  SP(Internal) is not correct. 
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  31.01.2014        Vers.: 3.0
//?nderung:  965366 Mal function of Block PIDConL FB1874 in startup
//
//Ge?ndert:  CT DC AA I HMI, Aggarwal,Hariom                    Datum:  31.01.2014        Vers.: 3.0
//?nderung:  854907: PIDConR_block :In Manual mode MV is not changing correctly during ManHiLim and ManLoLim violation 
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  10.02.2014        Vers.: 3.0
//?nderung:  966473 EventTs  Wrong status bit allocation for technological blocks when effective signals 1 ~ 8 of EventTs is connected and triggered
//
//Ge?ndert:  CT DC AA I HMI, Aggarwal,Hariom                    Datum:  19.02.2014        Vers.: 3.0
//?nderung:  854907: PIDConR_block :In Manual mode MV is not changing correctly during ManHiLim and ManLoLim violation 
//
//Ge?ndert:  CT DC AA I HMI, Aggarwal,Hariom                    Datum:  27.02.2014        Vers.: 3.0
//?nderung:  959690: PIDConL : Behaviour of  SP(Internal) is not correct. 
//
//Ge?ndert:  I IA AS PA R&D WF 4, Mohr, Dieter                  Datum:  12.03.2014        Vers.: 3.0
//?nderung: 983779 UDA S7_edit
//
//Ge?ndert:  CT DC AA I HMI, Gomasta,Abha                       Datum:  21.03.2014        Vers.: 3.0
//?nderung:  993286: PIDConL and PIDConR Block,Feature2.Bit5=1_Ignore Bad Signal State in Interlock Signal is not implemented.
//
//Ge?ndert:  I IA AS PA R&D WF 4, Mohr, Dieter                  Datum:  08.04.2014        Vers.: 3.0
//?nderung: 1009981 PR: BMSPCS7DOR320 - Fehlerhafte ByPass Anzeige
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  29.04.2014        Vers.: 3.0
//?nderung:  1024882 In FPs werden Variablen verwendet, die nicht gemappt sind
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  07.05.2014        Vers.: 3.0
//?nderung:  1026842 PIDConL and PIDCOnR : Block comment for input parameter "SafePos2" is not completely visible and incomplete.
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  07.05.2014        Vers.: 3.0
//?nderung:  1027143 PIDConL and PIDConR : Operational Area window for MV is not disabled while blocks are in interlocked condition with SafePos / SafePos2
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  06.06.2014        Vers.: 3.0
//?nderung: 1066339 The caculation of stop ramping is not correct.
//
//Ge?ndert:  CT DC AA DF PD, Gomasta,Abha                       Datum:  07.11.2014        Vers.: 3.0 [Release 08.01.00.01]
//?nderung:  1140229:Attribute "S7_Contact" for Parameter *ChnST is not neccessary
//
//------------------------------------ APL V8.2 --------------------------------------------------------
//Ge?ndert:  CT DC AA DF PD, K,Apoorva                          Datum:  10.03.2015        Vers.: 4.0  
//?nderung:  1233851: Author, Version in APL 8.2 blocks
//
//Ge?ndert:  CT DC AA DF PD, Gomasta,Abha                       Datum:  19.03.2015        Vers.: 4.0 
//?nderung:  983680:Different behavior on RmpTime vs RmpTarget with RateLim and PIDConL.
//
//Ge?ndert:  CT DC AA DF PD, Aggarwal,Hariom                    Datum:  04.05.2015        Vers.: 4.0
//?nderung:  1035851:CR: Controller have no error number for wrong setting of linkable inputs
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  10.06.2015        Vers.: 4.0
//?nderung:  1205458: error in step response if using deadband and P-part in feedback together
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  07.08.2015        Vers.: 4.0
//?nderung:  1398865: PIDConL, PIDConR, PIDConS : Readback value field should be invisible, when Rbk.ST = 16#FF in OOS mode
//
//------------------------------------ APL V8.2.1 --------------------------------------------------------
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  15.12.2015        Vers.: 4.1
//?nderung:  Requirement 1401617: Show PropFacSP and DiffToFbk in Faceplate of PIDConL, PIDConR, and PIDStepL
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  19.01.2016        Vers.: 4.1
//?nderung:  1307205 Setpoint limits
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  28.01.2016        Vers.: 4.1
//?nderung:  1580853 HUBUSA: PIDConR and PIDConL should have bumpless transfer from interlock
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  02.02.2016        Vers.: 4.1
//?nderung:  1396266 Faulty behavior of PropFacSP in PIDConL
//
//------------------------------------ APL V9.0 --------------------------------------------------------
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                 Datum:  12.07.2016        Vers.: 5.0  
//?nderung:  Requirement 1788915 PCS 7 V9.0 compatibility
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  21.07.2016        Vers.: 5.0
//?nderung:  Task 1794381 LIB PIDConL/R: Alarm Delay Times
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  04.08.2016        Vers.: 5.0
//?nderung:  1778713 PIDConL : FFwdHiAct & FFwdLoAct are not working.
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  10.08.2016        Vers.: 5.0
//?nderung:  1794339 LIB PIDConL/R/PIDStepL: SP-Ramp
//
//Ge?ndert:  CT DD DS AA DF-PD FH DEV SPT, Aggarwal,Hariom      Datum:  11.08.2016        Vers.: 5.0
//?nderung:  Task 1794383 LIB PIDConL/R: limits as outputs
//
//Ge?ndert:  I IA AS PA R&D DH 4, Mohr, Dieter                  Datum:  18.08.2016        Vers.: 5.0
//?nderung:  1794339 LIB PIDConL/R/PIDStepL: SP-Ramp
//           Remaining ramp time
//
//Ge?ndert:  PD PA AE R&D-I DH 4, Mohr, Dieter                  Datum:  19.08.2016        Vers.: 5.0
//?nderung:  1849418 : Batch name is not updated on the APL block
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  24.08.2016        Vers.: 5.0
//?nderung:  Task 1794381 LIB PIDConL/R: Alarm Delay Times
//
//Ge?ndert:  PD PA AE R&D-I DH 4, Mohr, Dieter                  Datum:  05.09.2016        Vers.: 5.0
//?nderung:  1794377 : LIB General: Tag Bypass (MonAnL,MonDiL,PIDConL/R, PIDStepL,TotalL)
//?nderung:  1794379 : LIB General: Lock bypass (Tag Bypass)
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                 Datum:  19.10.2016        Vers.: 5.0  
//?nderung:  1943365 PIDConL : Duration Mode Set Point Ramp function not working
//           1943366 PIDConL : Remaining Ramp Time ( SP_RemRT ) not working when TimeFactor=1 & 2.
//           1944961 PIDConL : PIDConL : UP-DOWN Gradient function not work when Change in Set Point
//
//Ge?ndert:  CT DD DS AA DF-PD FH DEV SPT, Aggarwal, Hariom     Datum:  27.10.2016        Vers.: 5.0  
//?nderung:  ID 1794377 : LIB General: Tag Bypass (MonAnL,MonDiL,PIDConL/R, PIDStepL,TotalL) 
// ResBypOp and ResBypLi changed to RstBypOp and RstBypLi respectively
//
//Ge?ndert:  PD PA AE R&D-I DH 4, Mohr, Dieter                  Datum:  02.11.2016        Vers.: 5.0
//Ge?ndert:  PD PA AE R&D-I DH 4, Mohr, Dieter                  Datum:  07.11.2016        Vers.: 5.0
//Ge?ndert:  PD PA AE R&D-I DH 4, Mohr, Dieter                  Datum:  07.12.2016        Vers.: 5.0
//?nderung:  1794379 LIB General: Lock bypass (Tag Bypass)
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  19.01.2017        Vers.: 5.0  
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  10.02.2017        Vers.: 5.0  
//?nderung:  2077128 : PIDConX: Indication of active SP ramp
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  24.02.2017        Vers.: 5.0  
//?nderung:  2140319 : <VlvAnL> The XX.ST statuses do not reset to 16#80 when the block is moved to OOS
//
//Ge?ndert:  CT DD DS AA DF-PD FH DEV SPT, Tejaswi K C          Datum:  28.02.2017        Vers.: 5.0  
//?nderung:  2139806 : Extended Interface of several APL blocks to support new TDRA 
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  31.03.2017     Vers.: 5.0  
//?nderung:  2211803 : PIDConX: Ramp behaviour in case of SP = external (interface preperation)
//
//------------------------------------ APL V9.0.1 --------------------------------------------------------
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  23.05.2017     Vers.: 5.1  
//?nderung:  2211789 : PIDConX: Ramp behaviour in case of SP = external
//   
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  19.05.2017     Vers.: 5.1  
//?nderung:  2244840 : PIDConL/PIDConR: Feature.Bit8( Separate time delay for each PV,ER Alarm) is not working for  ER_AH_DC
//   
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                 Datum:  04.08.2017        Vers.: 5.1  
//?nderung:  Feature 2436510 : Extended Tag Bypass (IntLckxx, MonAnL,MonDiL,PIDConL/R, PIDStepL,TotalL)
//
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                    Datum:  22.08.2017     Vers.: 5.1  
//?nderung:  2424344 : EventTS & Event16TS: Message lock for EventTS & Event16TS
//   
//Ge?ndert:  PD PA AE R&D DH 4, Mohr, Dieter                 Datum:  26.10.2017        Vers.: 5.1  
//?nderung:  2583046 TotalL: Wrong signal status  at Out.ST when bypass is made HIGH.
//
//------------------------------------ APL V9.0.2 --------------------------------------------------------
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  09.02.2018        Vers.: 5.2 
//?nderung:  2781968 Blocks with ramps: error in remaining ramp time SP_RemRT
//
//Ge?ndert:  CT RDA DS AA PD AE-I FH, Chaithanya, Krishna    Datum:  05.03.2018        Vers.: 5.2  
//?nderung:  1755816 APL General: Signal Status in OOS.
//
//Ge?ndert:  CT RDA DS AA PD AE-I FH, Aggarwal, Hariom    Datum:  20.03.2018        Vers.: 5.2  
//?nderung:  1755853 APL general use of limit values - out-greyed limit values.
//
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  05.04.2018        Vers.: 5.2 
//?nderung:  2800644 Feature Bit 30 must not be used if MV_Mean is not connected to related ConPerMon block
//
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  09.04.2018        Vers.: 5.2 
//?nderung:  2828860 PIDConL, PIDConR: Simulation of Rbk possible even though controller works without Rbk
//
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  16.04.2018        Vers.: 5.2 
//?nderung:  2715209 Removing in block I/O sections constants as default values
//
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  19.04.2018        Vers.: 5.2 
//?nderung:  2939433 Controller: No display of "Invalid signal" in area for block states
//
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  23.04.2018        Vers.: 5.2 
//?nderung:  2944942 MonAnL, controller: Associated value PV, Rbk instead of PV_Out, RbkOut
//
//Ge?ndert:  CT RDA DS AA PD AE-I FH DH3, Patange, Dhaval    Datum:  12.06.2018        Vers.: 5.2  
//?nderung:  1755853 APL general use of limit values - out-greyed limit values( removing feature bit 31).
//
//Ge?ndert:  CT RDA DS AA PD AE-I FH DH3, Tejaswi K C         Datum:  03.07.2018        Vers.: 5.2 
//?nderung:  3078455 PIDConL: SP_ExtOut.ST does not change to 16#60 when mode changed to OOS with Feature.bit5=1
//
//Ge?ndert:  CT RDA DS AA PD AE-I FH, Patange, Dhaval    Datum:  11.07.2018        Vers.: 5.2  
//?nderung:  3090624 Change activation of feature "General_use_of_limit_values" from OS variable  to feature bit.
//
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  12.07.2018        Vers.: 5.2 
//?nderung:  2949086 PIDConS block: In OOS mode both 'Channel MV' and simulation symbol is disappearing in preview view,
//           IF MV_ChnST.ST = 16#60
//
//Ge?ndert:  PD PA AE STS DH 4, Mohr, Dieter                 Datum:  12.07.2018        Vers.: 5.2 
//?nderung:  3088268 APL902 PIDConS, PIDConL MV jump after switch over from OOS mode to manual mode
//
//Ge?ndert:  CT RDA DS AA PD AE-I FH, Tejaswi K C               Datum:  01.08.2018        Vers.: 5.2
//?nderung:  3081478 APL_General: Change in signal status of applicable outputs is possible when Feature.bit->1 in OOS mode
//
//Ge?ndert:  CT RDA DS AA PD AE-I FH, Tejaswi K C               Datum:  21.08.2018        Vers.: 5.2
//?nderung:  3081478 APL_General: Change in signal status of applicable outputs is possible when Feature.bit->1 in OOS mode
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// compiler presets
{OverwriteBlocks        := 'y'}
{GenerateReferenceData  := 'n'}
{S7ServerActive         := 'y'}
{CreateObjectCode       := 'y'}
{OptimizeObjectCode     := 'y'}
{MonitorArrayLimits     := 'n'}
{CreateDebugInfo        := 'n'}
{SetOKFlag              := 'n'}
{SetMaximumStringLength := '254'}


FUNCTION_BLOCK "PIDConL"
TITLE = 'Continuous PID controller - Large'
{ S7_tasklist:= 'OB100'; S7_alarm_ui:= '1'; S7_m_c:= 'true' }

AUTHOR:              AdvLib90
NAME:                PIDConL
VERSION:             '5.2'
FAMILY:              Control
KNOW_HOW_PROTECT


 CONST
  C_OB_START           := INT#100; //Warm start OB
  C_OB_CYCLIC_MIN      := INT#30;  //Cyclic OB minimum range.
  C_OB_CYCLIC_MAX      := INT#38;  //Cyclic OB maximum range.
  C_ERROR_DEV          := INT#-1;  // Default Value
  C_ERROR_NO           := INT#00;  // No Error
  C_ERROR_NUM_PV       := INT#30;  // PV is infinity or not a number
  C_ERROR_NUM_SPEXT    := INT#31;  // SP_Ext is infinity or not a number
  C_ERROR_NUM_MVFEFORW := INT#32;  // FFwd is infinity or not a number
  C_ERROR_NUM_MVTRACK  := INT#33;  // MV_Track is infinity or not a number
  C_ERROR_NUM_MVFORCED := INT#34;  // MV_Forced is infinity or not a number
  C_ERROR_NUM_RBK      := INT#35;  // Rbk is infinity or not a number
  C_ERROR_NUM_MV       := INT#36;  // MV is infinity or not a number
  C_ERROR_TM           := INT#43;    // TimeFactor Error.
  C_TM_PERSEC          := INT#1;     // Conversion of TimeFactor to Per Second
  C_TM_PERMIN          := REAL#1.666667e-2;// Conversion of TimeFactor to Per Minute
  C_TM_PERHOUR         := REAL#2.777778e-4;// Conversion of TimeFactor to Per Hour
  C_ERROR_INVALID_SIGNAL := INT#51;  //Error number: Invalid signal state
  C_ERROR_FB30_MVMEAN  := INT#52;  // Feature Bit 30 is active and MV_Mean is not connected
  C_ERROR_NEGGAIN      := INT#59;  // Gain is negative
  C_ERROR_TI           := INT#60;  // |TI| < SampleTime/2
  C_ERROR_TD           := INT#61;  // |TD| < SampleTime
  C_ERROR_DIFFGAIN     := INT#62;  // DiffGain < 1.0 or DiffGain > 10.0
  C_ERROR_TD_DIFFGAIN  := INT#63;  // TD/DiffGain < SampleTime/2
  C_ERROR_PROPFACSP    := INT#64;  // PropFacSP < 0 or PropFacSP > 1
  C_ERROR_NORM_PV      := INT#66;  // NormPV_High = NormPV_Low
  C_ERROR_MOTORTIME    := INT#67;  // MotorTime < SampleTime
  C_ERROR_PULSETIME    := INT#68;  // PulseTime < SampleTime
  C_ERROR_BREAKTIME    := INT#69;  // BreakTime < SampleTime
  C_ERROR_CHANNEL      := INT#70;  // Channel Error: Channel < 0 or Channel > 3; FM355/FM355-2
  C_ERROR_D_IN_SEL     := INT#71;  // D_InSel Error: D_InSel < 0 or D_InSel > 4 and D_InSel<>17; FM355/FM355-2
  C_ERROR_CONZONE      := INT#74;  // ConZone Error: ConZone < 0
  C_SIZE_OF_EVT16TS    := 22;        //Byte length of Evt16Ts structure
 END_CONST

                                 //123456789012345678901234567890123456789012345678901234567890123456789012345
 VAR_INPUT

    NegGain     {S7_visible:='false'; S7_edit := 'para'}
                : DigVal;        // 0= GainEff is positive, 1= GainEff is negative
    Gain        {Op_Level:='2';BLK_Jump:='1';S7_edit := 'para';  S7_m_c:= 'true'; S7_xm_c:='Value,true;'}
                : STRUCT
                  Value : REAL := 1.0;  // Value
                  ST    : BYTE := 16#FF;    // Signal Status
                END_STRUCT;      // Proportional gain
    NormPV      {S7_visible:='false'; S7_edit := 'para'; S7_xedit:='High,para;Low,para;'}
                : ScaVal;        // PV range for normalizing the proportional gain (Gain)
    NormMV      {S7_visible:='false'; S7_edit := 'para'; S7_xedit:='High,para;Low,para;'}
                : ScaVal;        // MV range for normalizing the proportional gain (Gain)

    TI          {Op_Level:='2';S7_edit := 'para'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'}
                : STRUCT
                  Value : REAL := 100.0;    // Value
                  ST    : BYTE := 16#FF;    // Signal Status
                END_STRUCT;      // Integral time [s]
    IntHoldPos  {S7_visible:='false'}
                : DigVal;        // 1 = Integrator cannot run in positive direction
    IntHoldNeg  {S7_visible:='false'}
                : DigVal;        // 1 = Integrator cannot run in negative direction

    TD          {Op_Level:='2';S7_edit := 'para'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'} //S7_xm_c:='Value'
                : AnaValFF;        // Differential time (derivative time) [s]
    DiffGain    {Op_Level:='2';S7_visible:='false'; S7_edit := 'para'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'}
                : STRUCT
                  Value : REAL := 5.0;  // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // Gain of differentiator [1..10], DiffGain = TD / (time lag of D action)

    PropSel     {S7_visible:='false'}
                : BOOL := true;  // 1 = Activate P action
    DiffToFbk   {S7_visible:='false'; Op_Level:='2';S7_edit := 'para'; S7_m_c:='true'}
                : BOOL := false; // 1 = D action is moved to feedback path
    IntSel      {S7_visible:='false'}
                : BOOL := true;  // Select integral action
    DiffSel      {S7_visible:='false'}
                : BOOL := true;  // Select D action

    PropFacSP   {S7_visible:='false'; Op_Level:='2';S7_edit := 'para'; S7_m_c:='true'}
                : REAL := 1.0;   // P action to feedback path [0..1]: 0 = P action fully in feedback path
    DeadBand    {S7_visible:='false'; Op_Level:='2';S7_edit := 'para'; S7_m_c:='true'}
                : REAL := 0.0;   // Width of deadband

    ConZone     {S7_visible:='false'; Op_Level:='2';S7_edit := 'para'; S7_m_c:='true'}
                : REAL := 0.0;   // Width of control zone

    SP_LiOp     {S7_edit := 'para'; S7_contact:='true'}
                : DigVal;        // Select setpoint source via 1 = interconnection, 0 = operator
    SP_ExtOp    {S7_edit := 'para'; Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                : BOOL := false; // 1 = Select external setpoint (via operator)
    SP_IntOp    {S7_edit := 'para'; Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                : BOOL := false; // 1 = Select internal setpoint (via operator)
    SP_ExtLi    {S7_contact:='true'}
                : DigVal;        // 1 = Select external setpoint (via interconnection)
    SP_IntLi    {S7_contact:='true'}
                : DigVal;        // 1 = Select internal setpoint (via interconnection)

    SP_Int      {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_dynamic:='true'}
                : REAL := 0.0;   // Internal setpoint for operation
    SP_InHiLim  {Op_Level:='2';S7_edit := 'para'; S7_visible:='false'; S7_m_c:='true'}
                : REAL := 100.0; // High limit of internal setpoint
    SP_InLoLim  {Op_Level:='2';S7_edit := 'para'; S7_visible:='false'; S7_m_c:='true'}
                : REAL := 0.0;   // Low limit of internal setpoint
    SP_Ext      {S7_dynamic:='true'; S7_contact:='true'}
                : AnaVal;        // External setpoint (to be interconnected)
    SP_ExHiLim  {S7_edit := 'para'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'}
                : STRUCT
                  Value : REAL := 100.0;    // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // High limit for external setpoint
    SP_ExLoLim  {S7_edit := 'para'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'}
                : AnaVal;        // Low limit for external setpoint

    SP_TrkPV    {Op_Level:='2';S7_edit := 'para'; S7_visible:='false'; S7_m_c:='true'}
                : BOOL := false; // 1 = Setpoint follows PV in manual mode and in tracking
    SP_TrkExt   {Op_Level:='2';S7_edit := 'para'; S7_visible:='false'; S7_m_c:='true'}
                : BOOL := true;  // 1 = Bumpless switchover from external to internal setpoint active

    SP_RateOn   {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'}
                : BOOL := false; // 1= Activate limitation of setpoint gradients
    SP_RmpOn    {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'}
                : BOOL := false; // 1= Activate setpoint ramp to target SP_RmpTarget
    SP_RmpModTime {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'}
                : BOOL := false; // 1= Use time SP_RmpTime for ramp, 0= Use rates SP_UpRaLim, SP_DnRaLim

    SP_UpRaLim  {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'}
                : REAL := 100.0; // Upward rate limit of setpoint
    SP_LiUpRaLim {S7_visible:='false'}
                : AnaValFF; // Linkable upward rate limit of setpoint
    SP_DnRaLim  {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'}
                : REAL := 100.0; // Downward rate limit of setpoint
    SP_LiDnRaLim {S7_visible:='false'}
                : AnaValFF; // Linkable downward rate limit of setpoint
    SP_RmpTime   {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'}
                : REAL := 0.0;   // Setpoint ramp time [s,min,h]
    SP_LiRmpTime {S7_visible:='false'}
                : AnaValFF; // Linkable setpoint ramp time [s,min,h]

    SP_RmpTarget {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_dynamic:='true'}
                : REAL := 0.0;   // Setpoint ramp target

    PV          {S7_dynamic:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_xqc:='Value,true;'}
                : AnaVal;        // Process value (controlled variable)

    PV_AH_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 95.0;  // PV alarm high limit
    PV_WH_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 90.0;  // PV warning high limit
    PV_TH_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 85.0;  // PV tolerance message high limit
    PV_TL_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 15.0;  // PV tolerance message low limit
    PV_WL_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 10.0;  // PV warning low limit
    PV_AL_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 5.0;   // PV alarm low limit
    PV_Hyst     {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 1.0;   // Hysteresis for PV alarms, warnings and tolerance messages

    PV_AH_DC     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming PV high alarms [s]
    PV_AH_DG     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing PV high alarms [s]
    PV_WH_DC     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming PV high warnings [s]
    PV_WH_DG     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing PV high warnings [s]
    PV_TH_DC     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming PV high tolerance messages [s]
    PV_TH_DG     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing PV high tolerance messages [s]

    PV_A_DC     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming PV high/low or only low alarms [s]
    PV_A_DG     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing PV high/low or only low alarms [s]
    PV_W_DC     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming PV high/low or only low warnings [s]
    PV_W_DG     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing PV high/low or only low warnings [s]
    PV_T_DC     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming PV high/low or only low tolerance messages [s]
    PV_T_DG     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing PV high/low or only low tolerance messages [s]

    PV_AH_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable PV alarm high
    PV_WH_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable PV warning high
    PV_TH_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := false;  // 1 = Enable PV tolerance message high
    PV_TL_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := false;  // 1 = Enable PV tolerance message low
    PV_WL_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable PV warning low
    PV_AL_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable PV alarm low
    PV_AH_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for PV alarm high
    PV_WH_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for PV warning high
    PV_TH_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true; // 1 = Enable message for PV tolerance message high
    PV_TL_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true; // 1 = Enable message for tolerance message low
    PV_WL_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for PV warning low
    PV_AL_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for PV alarm low

    ER_Ext      {S7_visible:='false'; S7_dynamic:='true'}
                : AnaVal;        // External control error

    ER_AH_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 100.0; // ER alarm high limit
    ER_AL_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := -100.0;// ER alarm low limit
    ER_Hyst     {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 1.0;   // Hysteresis for ER alarms

    ER_AH_DC    {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming ER high alarms [s]
    ER_AH_DG    {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing ER high alarms [s]

    ER_A_DC     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for incoming ER high/low or only low alarms [s]
    ER_A_DG     {S7_visible:='false'; S7_edit:='para'}
                : REAL := 0.0;   // Delay time for outgoing ER high/low or only low alarms [s]

    ER_AH_DFac  {Op_Level:='2'; S7_visible:='false'; S7_m_c:='true'}
                : REAL := 0.0; // ER alarm coming delay factor for positive SP jump [s/PV_Unit]
    ER_AL_DFac  {Op_Level:='2'; S7_visible:='false'; S7_m_c:='true'}
                : REAL := 0.0; // ER alarm coming delay factor for negative SP jump [s/PV_Unit]

    ER_AH_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable ER alarm high
    ER_AL_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable ER alarm low
    ER_AH_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for ER alarm high
    ER_AL_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for ER alarm low

    MV_Offset   {S7_visible:='false'; S7_contact:='true'}
                : REAL := 0.0;   // MV for ER= 0, operating point for controller without I action

    FFwd        {S7_visible:='false'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_xqc:='Value,true;'; S7_dynamic:='true'; S7_contact:='true'; S7_xtrend:='Value,MV_OpScale.Low,MV_OpScale.High;'}
                : AnaVal;        // Input for additive disturbance variable compensation
    FFwdHiLim   {S7_visible:='false'; S7_edit := 'para'}
                : STRUCT
                  Value : REAL := 100.0;    // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // High limit for additive disturbance variable compensation
    FFwdLoLim   {S7_visible:='false'; S7_edit:='para'}
                : STRUCT
                  Value : REAL := -100.0;   // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // Low limit for additive disturbance variable compensation

    MV_TrkOn    {S7_dynamic:='true'; S7_contact:='true'}
                : DigVal;        // 1 = Tracking of manipulated variable MV
    MV_Trk      {S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_xqc:='Value,true;'; S7_dynamic:='true'; S7_contact:='true'}
                : AnaVal;        // Tracking value for manipulated variable MV

    ModLiOp     {S7_edit := 'para'; S7_contact:='true'}
                : DigVal;        // Mode selection via 0 = Operator, 1 = Interconnection or SFC
    AutModOp    {S7_edit := 'para'; Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                : BOOL := false; // 1 = Automatic mode by operator (controlled by ModLiOp = 0)
    ManModOp    {S7_edit := 'para'; Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                : BOOL := true;  // 1 = Manual mode by operator (controlled by ModLiOp = 0)
    AutModLi    {S7_dynamic := 'true'; S7_contact:='true'}
                : DigVal;        // 1 = Automatic mode by interconnection or SFC (controlled by ModLiOp = 1)
    ManModLi    {S7_dynamic := 'true'}
                : DigVal;        // 1 = Manual mode by interconnection or SFC (controlled by ModLiOp = 1)

    AdvCoEn     {S7_visible:='false'}
                : DigVal;        // 1 = Enable program mode via interconnection
    AdvCoOn     {S7_edit := 'para'; Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                : BOOL := false; // 1 = Enable program mode via faceplate
    AdvCoModSP  {S7_visible:='false'}
                : BOOL := true;  // Type of program mode: 1 = Setpoint target, 0 = Manipulated variable target
    AdvCoMstrOn {S7_visible:='false'}
                : DigVal; // Activate (0-1) or deactivate (1-0) program via edge transition
    AdvCoMV     {S7_visible:='false'; S7_m_c:='true'}: REAL := 0; // Target value from the external program

    OosOp       {S7_edit := 'para'; Op_Level:='2';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                : BOOL := false; // 1 = Out of service by OS operation
    OosLi       {S7_dynamic:='true'}
                : DigVal;        // 1 = Out of service via interconnection or SFC (0-1 edge transition)

    MS_RelOp    {Op_Level:='3';S7_visible:='false'; S7_m_c:='true'}
                : BOOL := false; // 1 = Release for maintenance by operator

    OptimEn     {Op_Level:='2';S7_visible:='false'; S7_m_c:='true'}
                : BOOL := false; // 1 = Enable optimization of PID parameters by PID tuner
    OptimOcc    {S7_visible:='false'; S7_link:='false'}
                : BOOL := false; // 1 = Optimization running

    CPI_In      {S7_visible:='false'; BLK_Jump:='1';S7_edit := 'para'; S7_xqc:='Value,true;';S7_dynamic:='true';S7_m_c:= 'true'; S7_xm_c:='Value,true;'}
                : STRUCT
                  Value : REAL := 0.0;  // Value
                  ST    : BYTE := 16#78;    // Signal Status
                END_STRUCT;      // Input for control performance index calculated by related ConPerMon block
    RefStdDevIn {S7_visible:='false'}
                : STRUCT
                  Value : REAL := 0.0;  // Value
                  ST    : BYTE := 16#78;    // Signal Status
                END_STRUCT;      // Reference value of PV standard deviation in "good" state of control loop

    MV_Mean     : STRUCT
                  Value : REAL := 0.0;  // Value
                  ST    : BYTE := 16#78;    // Signal Status
                END_STRUCT;      // Mean value of MV in moving time window
    SettliTime : STRUCT
                  Value : REAL := 0.0;  // Value
                  ST    : BYTE := 16#78;    // Signal Status
                END_STRUCT;      // Settling time [s] of control loop as  caclulated by related ConPerMon block
    SettliFactor{S7_visible:='false'}
                : REAL:= 2; // Factor to increase settling time for deadband adaptation

    Man         {Op_Level:='1';S7_visible:='false'; S7_m_c:='true'}
                : REAL := 0.0;   // Operator input for manual setting of manipulated variable MV
    ManHiLim    {Op_Level:='2';S7_edit := 'para'; S7_visible:='false'; S7_m_c:='true'}
                : REAL := 100.0; // High limit for manipulated variable in manual mode
    ManLoLim    {Op_Level:='2';S7_edit := 'para'; S7_visible:='false'; S7_m_c:='true'}
                : REAL := 0.0;   // Low limit for manipulated variable in manual mode
    MV_HiLim    {S7_edit := 'para'}
                : STRUCT
                  Value : REAL := 100.0;    // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // Limit (high) for manipulated variable MV
    MV_LoLim    {S7_edit := 'para'}
                : AnaVal;        // Limit (low) for manipulated variable MV

    MV_ForOn    {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // Select bypassed MV supplied by input MV_Forced, e.g. for emergency shutdown
    MV_Forced   {S7_visible:='false'; S7_dynamic:='true'}
                : AnaVal;        // Bypassed value for MV, which is not limited and has highest priority

    SafePos     {S7_edit := 'para'; S7_visible:='false'}
                :BOOL := false; // 1= Rest position for MV is ManHiLim, 0= Rest position for MV is ManLoLim
    SafePos2    {S7_edit := 'para'; S7_visible:='false'}
                :INT := 0;      // 0= SafePos is valid, 1= Rest pos. is MV_SafePos, 2= Rest pos. is last MV (Stop)
    MV_SafePos  {S7_edit := 'para'; S7_dynamic:='true'}
                : AnaVal;       // MV rest position

    BypProt     {S7_edit := 'para'; S7_m_c := 'true';  S7_visible := 'false'}
                :BOOL := FALSE; // Bypass Protection in Sim Modes

    Intlock     {BLK_Jump:='1';S7_dynamic := 'true'; S7_m_c := 'true'; S7_xm_c := 'Value,true;'; S7_xqc := 'Value,true;'; S7_read_back:='never'}
                :STRUCT
                      Value  : BOOL := true;  // Value
                      ST     : BYTE := 16#FF;  // Signal Status
                END_STRUCT; // 0=Controller is Interlocked, 1=Controller is Not Interlocked
        StcDigValIntlock AT Intlock : STRUCT
                    Value : BOOL;   // Value
                    Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                    ST    : BYTE;   // Signal Status
                              END_STRUCT;
    Intl_En     {S7_edit := 'para'; S7_visible := 'false'}
                :BOOL := TRUE; // 1=Interlock enabled, 0=Interlock disabled

    Rbk         {S7_dynamic:='true'}
                : AnaValFF;      // Readback value (only for display in faceplate)
    RbkWH_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 100.0; // Rbk warning high limit
    RbkWL_Lim   {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 0.0;   // Rbk warning low limit
    RbkHyst     {Op_Level:='2';S7_visible:='false'; S7_edit:='para'; S7_m_c:='true'}
                : REAL := 1.0;   // Hysteresis for Rbk warnings
    RbkWH_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable Rbk warning high
    RbkWL_En    {S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable Rbk warning low
    RbkWH_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for Rbk warning high
    RbkWL_MsgEn {Op_Level:='2'; S7_m_c:= 'true'; S7_edit := 'para'; S7_visible:='false'}
                : BOOL := true;  // 1 = Enable message for Rbk warning low

    BypLiOp     {S7_visible:='false'; S7_edit := 'para'; S7_dynamic := 'true'}
                :DigVal;        // 1 = Bypass commands via interconnection
    BypPVOp     {S7_edit := 'para'; Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                :BOOL := false; // 1 = Select bypass PV (via operator)
    RstBypOp    {S7_edit := 'para'; Op_Level:='1';S7_visible:='false'; S7_m_c:='true'; S7_string_1 := ''}
                :BOOL := false; // 1 = Reset bypass PV (via operator)
    BypPVLi     {S7_visible:='false'}
                :DigVal;        // 1 = Select bypass PV (via interconnection)
    RstBypLi    {S7_visible:='false'}
                :DigVal;        // 1 = Reset bypass PV (via interconnection)
    BypPV       {S7_visible:='false'; S7_edit:='para'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'} 
                :AnaValFF;   // Substitution value if block is in bypass
    BypLock     {S7_visible:='false'}
                :DigVal;        // 1 = Bypass activation or deactivation is locked for operator

    SimLiOp     {S7_edit := 'para'; S7_visible:='false'}
                :DigVal;       // Simulation on/off via 0 = Operator, 1 = Interconnection or SFC
    SimOnLi     {S7_visible:='false'}
                :DigVal;       // 1 = Simulation activated by interconnection or SFC (controlled by SimLiOp = 1)
    SimOn       {Op_Level:='3';S7_visible:='false'; S7_m_c:='true'}
                :BOOL := FALSE;  // 1 = Simulation activated
    SimPV       {Op_Level:='1';S7_visible:='false'; S7_m_c:= 'true'}
                :REAL := 0.0;    // Process value used for SimOn = 1
    SimPV_Li    {S7_visible:='false'}
                :AnaVal;    // Linkable simulation value PV
    SimRbk      {Op_Level:='1';S7_visible:='false'; S7_m_c:= 'true'}
                :REAL := 0.0;    // Readback value used for SimOn = 1
    SimRbkLi    {S7_visible:='false'}
                :AnaVal;    // Linkable simulation value Rbk

    PV_OpScale  {S7_m_c:='true'; S7_xm_c:='High,true;Low,true;'; S7_edit := 'para'; S7_xedit:='High,para;Low,para;'}
                : ScaVal;        // Limit values for scale in PV bar display of faceplate
    MV_OpScale  {S7_m_c:='true'; S7_xm_c:='High,true;Low,true;'; S7_edit := 'para'; S7_xedit:='High,para;Low,para;'}
                : ScaVal;        // Limit values for scale in MV bar display of faceplate
    PV_Unit     {S7_m_c:='true'; S7_edit:='para'; S7_unit:=''}
                : INT := 1001;   // Unit of measurement for the process value
    MV_Unit     {S7_m_c:='true'; S7_edit:='para'; S7_unit:=''}
                : INT := 1342;   // Unit of measurement for manipulated variable

    MV_ChnST    {S7_dynamic := 'true'; S7_m_c := 'true'; S7_xm_c := 'Value,true;'; S7_xqc := 'Value,true;'}
                :AnaValFF;      // Output channel state of MV

    SampleTime  {S7_visible:='false'; S7_link:='false'; S7_sampletime:='true'; S7_param:='false'}
                : REAL := 0.1;   // Sampling time [s] (assigned automatically)

    TimeFactor  {S7_visible:='false'; S7_edit := 'para'; S7_m_c :='true'}
                :INT := 0;       // Time Conversion Factor (0- Sec, 1- Min, 2- Hour)

    UserStatus  {S7_m_c:='true'; S7_visible:='false'}
                : BYTE := 16#0;  // Freely assignable bits for use in faceplate

    RunUpCyc    {S7_visible:='false'}
                : INT := 3;      // Number of cycles in startup; messages are suppressed during these cycles
    MsgEvID1    {S7_visible:='false'; S7_link:='false'; S7_param :='false'; S7_server:='alarm_archiv'; S7_a_type:='alarm_8p'}
                : DWORD := 16#00000000; //Message Event ID
    MsgEvID2    {S7_visible:='false'; S7_link:='false'; S7_param :='false'; S7_server:='alarm_archiv'; S7_a_type:='alarm_8p'}
                : DWORD := 16#00000000; //Message Event ID

    BatchEn     {S7_visible:='false'}
                : BOOL := false; // 1 = Enable allocation for batch control
    BatchID     {S7_visible:='false'; S7_m_c:='true'}
                : DWORD := 0;    // Batch number
    BatchName   {S7_visible:='false'; S7_m_c:='true'}
                : STRING[32] := ''; // Batch name
    StepNo      {S7_visible:='false'; S7_m_c:='true'}
                : DWORD := 0;    // Batch step number
    Occupied    {S7_visible:='false'}
                : BOOL := false; // 1 = Occupied by batch control

    CSF         {S7_dynamic:='true'}
                : DigVal;        // 1 = External error (control system error)
    ExtMsg1     {S7_visible:='false'}
                : DigVal;        // 1 = Binary input for freely selectable message 1
    ExtMsg2     {S7_visible:='false'}
                : DigVal;        // 1 = Binary input for freely selectable message 2
    ExtMsg3     {S7_visible:='false'}
                : DigVal;        // 1 = Binary input for freely selectable message 3
    ExtMsg4     {S7_visible:='false'}
                : DigVal;        // 1 = Binary input for freely selectable message 4

    MsgLock     {S7_visible:='false'}
                : DigVal;        // Inhibit process message

    ExtVa106    {S7_visible:='false'}
                : ANY;           // Associated value 6 for messages (MsgEvID1)
    ExtVa107    {S7_visible:='false'}
                : ANY;           // Associated value 7 for messages (MsgEvID1)
    ExtVa209    {S7_visible:='false'}
                : ANY;           // Associated value 9 for messages (MsgEvID2)
    ExtVa210    {S7_visible:='false'}
                : ANY;           // Associated value 10 for messages (MsgEvID2)

    OS_Perm     {S7_visible:='false'}
                : STRUCT
                      Bit0: BOOL :=1; // 1= Operator can switch into automatic mode AutModOp
                      Bit1: BOOL :=1; // 1= Operator can switch into manual mode ManModOp
                      Bit2: BOOL :=1; // 1= Operator can switch into "out of service" mode OosOp
                      Bit3: BOOL :=1; // 1= Operator can switch into program mode AdvCoOn
                      Bit4: BOOL :=1; // 1= Operator can switch the setpoint to external SP_ExtOp
                      Bit5: BOOL :=1; // 1= Operator can switch the setpoint to internal SP_IntOp
                      Bit6: BOOL :=1; // 1= Operator can change the internal setpoint SP_Int
                      Bit7: BOOL :=1; // 1= Operator can change the manual parameter Man
                      Bit8: BOOL :=1; // 1= Operator can change setpoint high limit SP_InHiLim
                      Bit9: BOOL :=1; // 1= Operator can change setpoint low limit SP_InLoLim
                     Bit10: BOOL :=1; // 1= Operator can change high limit for parameter Man ManHiLim
                     Bit11: BOOL :=1; // 1= Operator can change low limit for parameter Man ManLoLim
                     Bit12: BOOL :=1; // 1= Operator can use the setpoint's gradient limitation funct. SP_RateOn
                     Bit13: BOOL :=1; // 1= Operator can change the setpoint's upward rate limit SP_UpRaLim
                     Bit14: BOOL :=1; // 1= Operator can change the setpoint's downward rate limit SP_DnRaLim
                     Bit15: BOOL :=1; // 1= Operator can change ramp mode (time or gradient value) SP_RmpModTime
                     Bit16: BOOL :=1; // 1= Operator can change the ramp time SP_RmpTime
                     Bit17: BOOL :=1; // 1= Operator can change the target setpoint in ramp function SP_RmpTarget
                     Bit18: BOOL :=1; // 1= Operator can activate the setpoint ramp function SP_RmpOn
                     Bit19: BOOL :=1; // 1= Operator can enable the PID optimization function OptimEn
                     Bit20: BOOL :=1; // 1= Operator can activate the tracking of setpoint in manual mode SP_TrkPV
                     Bit21: BOOL :=1; // 1= Operator can activate bumpless changeover external/internal SP_TrkExt
                     Bit22: BOOL :=1; // 1= Operator can change the gain parameter Gain
                     Bit23: BOOL :=1; // 1= Operator can change the integral time parameter TI
                     Bit24: BOOL :=1; // 1= Operator can change the derivative time parameter TD
                     Bit25: BOOL :=1; // 1= Operator can change the derivative gain parameter DiffGain
                     Bit26: BOOL :=1; // 1= Operator can change the deadband parameter DeadBand
                     Bit27: BOOL :=1; // 1= Operator can change the control zone parameter ConZone
                     Bit28: BOOL :=1; // 1= Operator can change the derivative gain parameter ER_AH_DFac
                     Bit29: BOOL :=1; // 1= Operator can change the derivative gain parameter ER_AL_DFac
                     Bit30: BOOL :=1; // Reserved
                     Bit31: BOOL :=1; // Reserved
                END_STRUCT; // Operator permissions
    ArrOS_Perm AT OS_Perm : ARRAY[0..3] OF BYTE;
    OS1Perm     {S7_visible:='false'}
                : STRUCT
                      Bit0: BOOL :=1; // 1 = Operator can change the process value high alarm limit PV_AH_Lim
                      Bit1: BOOL :=1; // 1 = Operator can change the process value high warning limit PV_WH_Lim
                      Bit2: BOOL :=1; // 1 = Operator can change the process value high tolerance limit PV_TH_Lim
                      Bit3: BOOL :=1; // 1 = Operator can change the process value hysteresis PV_Hyst
                      Bit4: BOOL :=1; // 1 = Operator can change the process value low tolerance limit PV_TL_Lim
                      Bit5: BOOL :=1; // 1 = Operator can change the process value low warning limit PV_WL_Lim
                      Bit6: BOOL :=1; // 1 = Operator can change the process value low alarm limit PV_AL_Lim
                      Bit7: BOOL :=1; // 1 = Operator can change the control error high alarm limit ER_AH_Lim
                      Bit8: BOOL :=1; // 1 = Operator can change the control error message hysteresis ER_Hyst
                      Bit9: BOOL :=1; // 1 = Operator can change the control error low alarm limit ER_AL_Lim
                     Bit10: BOOL :=1; // 1 = Operator can change the position feedback high warning limit RbkWH_Lim
                     Bit11: BOOL :=1; // 1 = Operator can change the position feedback message hysteresis RbkHyst
                     Bit12: BOOL :=1; // 1 = Operator can change the position feedback low warning limit RbkWL_Lim
                     Bit13: BOOL :=1; // Reserved
                     Bit14: BOOL :=1; // 1 = Operator can activate bypass functionality
                     Bit15: BOOL :=1; // 1 = Operator can deactivate bypass functionality
                     Bit16: BOOL :=1; // 1 = Operator can activate the simulation function SimOn
                     Bit17: BOOL :=1; // 1 = Operator can activate the maintenance release function MS_RelOp
                     Bit18: BOOL :=1; // 1 = Operator can activate/deactivate message over PV_AH_MsgEn
                     Bit19: BOOL :=1; // 1 = Operator can activate/deactivate message over PV_WH_MsgEn
                     Bit20: BOOL :=1; // 1 = Operator can activate/deactivate message over PV_TH_MsgEn
                     Bit21: BOOL :=1; // 1 = Operator can activate/deactivate message over PV_TL_MsgEn
                     Bit22: BOOL :=1; // 1 = Operator can activate/deactivate message over PV_WL_MsgEn
                     Bit23: BOOL :=1; // 1 = Operator can activate/deactivate message over PV_AL_MsgEn
                     Bit24: BOOL :=1; // 1 = Operator can activate/deactivate message over ER_AH_MsgEn
                     Bit25: BOOL :=1; // 1 = Operator can activate/deactivate message over ER_AL_MsgEn
                     Bit26: BOOL :=1; // 1 = Operator can activate/deactivate message over RbkWH_MsgEn
                     Bit27: BOOL :=1; // 1 = Operator can activate/deactivate message over RbkWL_MsgEn
                     Bit28: BOOL :=1; // 1 = Operator can change the simulation value SimPV
                     Bit29: BOOL :=1; // 1 = Operator can change the simulation value SimRbk
                     Bit30: BOOL :=1; // 1= Operator can activate D action to feedback path DiffToFbk
                     Bit31: BOOL :=1; // 1= Operator can change P action to feedback path PropFacSP
                END_STRUCT; // Operator Permissions 1
    ArrOS1Perm AT OS1Perm : ARRAY[0..3] OF BYTE;

    OpSt_In     {BLK_Jump:='1'; S7_visible:='false'}
                :DWORD := 16#0;  // Enabled operator station

    Feature     {S7_visible:='false'}
                : STRUCT
                      Bit0: BOOL :=0; // 0 = Start up with defined initializing in OB100; 1 = keep last stored values
                      Bit1: BOOL :=0; // 1 = OosLi can switch to Out of Service (the block has to be in manual mode)
                      Bit2: BOOL :=0; // 1 = All linkable command inputs reset after evaluation
                      Bit3: BOOL :=0; // Reserved
                      Bit4: BOOL :=0; // 0 = Button mode; 1 = Switch mode: depend on SP_ExtLi AutModLi
                      Bit5: BOOL :=0; // 1 = Changes Signal status of outputs in OOS to 16#60
                      Bit6: BOOL :=0; // 1=Ramp rate is calculated with actual start point and actual ramp target value
                      Bit7: BOOL :=0; // Reserved
                      Bit8: BOOL :=0; // 1 = Separate delay times for each PV, ER alarm
                      Bit9: BOOL :=0; // 1 = Substitution value is activ if block is in bypass
                     Bit10: BOOL :=0; // Reserved
                     Bit11: BOOL :=0; // 1 = Gradient limitation with time duration
                     Bit12: BOOL :=0; // 1 = Control zone with preset I-part
                     Bit13: BOOL :=0; // 1 = Control zone with frozen I-part
                     Bit14: BOOL :=0; // 1 = External control error on
                     Bit15: BOOL :=0; // 1 = The controller goes to the rest position during "Out of service" mode
                     Bit16: BOOL :=0; // 1 = The controller goes to the rest position during startup
                     Bit17: BOOL :=0; // Reserved
                     Bit18: BOOL :=0; // 1 = Changeover to automatic mode with P action jump
                     Bit19: BOOL :=0; // Reserved
                     Bit20: BOOL :=0; // Reserved
                     Bit21: BOOL :=0; // Reserved
                     Bit22: BOOL :=0; // 1 = Enable message state actualization
                     Bit23: BOOL :=0; // 1 = SP follows PV in open loop has no priority over SP_Ext and SP limits
                     Bit24: BOOL :=0; // 1 = Local authorization active
                     Bit25: BOOL :=0; // 1 = Suppress all messages if MsgLock = 1
                     Bit26: BOOL :=0; // 1 = Reset switching points if switching to Out of Service
                     Bit27: BOOL :=0; // Reserved
                     Bit28: BOOL :=0; // 1 = Disable switching points if MsgLock =1
                     Bit29: BOOL :=0; // 1 = Signal value =0 (0 active) if limit is violated
                     Bit30: BOOL :=0; // 1 = Apply the dynamically deactivating of deadband during the PV settling
                     Bit31: BOOL :=0; // 1 = Limits disabled in faceplate
                END_STRUCT; // Status of various features

    Feature2    {S7_visible:='false'}
                : STRUCT
                      Bit0: BOOL :=0; // Reserved
                      Bit1: BOOL :=0; // Reserved
                      Bit2: BOOL :=0; // 1 = Separate evaluation of bypassed and simulated interlock signals
                      Bit3: BOOL :=0; // Reserved
                      Bit4: BOOL :=0; // Reserved
                      Bit5: BOOL :=0; // 1=Ignore bad signal state in interlock signals
                      Bit6: BOOL :=0; // Reserved
                      Bit7: BOOL :=0; // Reserved
                      Bit8: BOOL :=0; // Reserved
                      Bit9: BOOL :=0; // Reserved
                     Bit10: BOOL :=0; // Reserved
                     Bit11: BOOL :=0; // 1 = Suppress MsgLock and "Out of service" for connected message block
                     Bit12: BOOL :=0; // Reserved
                     Bit13: BOOL :=0; // Reserved
                     Bit14: BOOL :=0; // Reserved
                     Bit15: BOOL :=0; // Reserved
                     Bit16: BOOL :=0; // Reserved
                     Bit17: BOOL :=0; // Reserved
                     Bit18: BOOL :=0; // Reserved
                     Bit19: BOOL :=0; // Reserved
                     Bit20: BOOL :=0; // Reserved
                     Bit21: BOOL :=0; // Reserved
                     Bit22: BOOL :=0; // Reserved
                     Bit23: BOOL :=0; // Reserved
                     Bit24: BOOL :=0; // Reserved
                     Bit25: BOOL :=0; // Reserved
                     Bit26: BOOL :=0; // Reserved
                     Bit27: BOOL :=0; // Reserved
                     Bit28: BOOL :=0; // Reserved
                     Bit29: BOOL :=0; // Reserved
                     Bit30: BOOL :=0; // Reserved
                     Bit31: BOOL :=0; // Reserved
                END_STRUCT; // Status of various features

    SelFp1      {BLK_Jump:='1';S7_visible:='false'}
                :ANY; // 1 = Call an additional faceplate?in standard view

    SelFp2      {BLK_Jump:='1';S7_visible:='false'}
                :ANY; // 1 = Call an additional faceplate?in preview view

    EventTsIn   {S7_visible:='false'}
                :ANY; // Timestamp parameters
    anyEvtTsIn AT EventTsIn:   Struct_ANY;

    EnAcquire   {S7_dynamic := 'true'; S7_param := 'true'}
                : BOOL := TRUE; //Reserved

    AcquireId   {S7_visible := 'false'; S7_m_c := 'true'}
                : DWORD; //Reserved
                
    AcRequest   {S7_visible := 'false'; S7_contact := 'true'; S7_enum := 'ES_AcquireTypes'}
                : BYTE;   //Reserved
                
    AcPriority  {S7_visible := 'false'; S7_contact := 'true'}
                : BYTE;   //Reserved
                                
    AcWaitTmMax {S7_visible := 'false'; S7_contact := 'true'}
                : REAL;   //Reserved
                
    AcSafeOrMsk {S7_visible := 'false'; S7_contact := 'true'}
                : DWORD;  //Reserved
                
    AcSafeNotMsk {S7_visible := 'false'; S7_contact := 'true'}
                : DWORD;  //Reserved
                
    AcAcquireId {S7_visible := 'false'; S7_contact := 'true'}
                : DWORD;  //Reserved

 END_VAR


 VAR_OUTPUT

    MV          {S7_dynamic:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;';S7_xqc:='Value,true;'; S7_xtrend:='Value,MV_OpScale.Low,MV_OpScale.High;'; S7_edit:='para'}
                : AnaVal;        // Manipulated variable, Control output
    MV_HiAct    {S7_visible:='false'; S7_dynamic:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_edit:='para'}
                : DigVal;        // MV high limit is actively restricting manipulated variable
    MV_LoAct    {S7_visible:='false'; S7_dynamic:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_edit:='para'}
                : DigVal;        // MV low limit is actively restricting manipulated variable

    ManHiOut    {S7_visible:='false'}
                : STRUCT
                  Value : REAL := 100.0;    // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // High limit for Man
    ManLoOut    {S7_visible:='false'}
                : AnaVal;        // Low limit for Man

    RbkOut      {S7_visible:='false'; S7_dynamic:='true'; S7_contact:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_xqc:='Value,true;'; S7_edit:='para'}
                : AnaVal;        // Readback value output
    RbkWH_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = Rbk warning high active
    RbkWL_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = Rbk warning low active

    LockAct     {S7_visible := 'false'; S7_dynamic := 'true'}
                :DigVal ; // 1 = Interlock is active

    MS_Release  : DigVal; // Release for maintenance; 1 = Permission from operator

    GrpErr      {S7_dynamic := 'true'; S7_contact:='true'}
                :DigVal ; // 1 = Group error is active

    RdyToStart  {S7_dynamic := 'true'; S7_contact:='true'}
                :DigVal ; // 1 = ready to start

    OosAct      {S7_dynamic:='true'; S7_m_c:= 'true'; S7_xm_c:= 'Value,true;'} //S7_m_c because special case in symbol
                : DigVal; // 1 = Block is "Out of service"

    ManAct      {S7_dynamic:='true'}
                : STRUCT
                  Value : BOOL := true; // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // 1 = Manual mode active
    AutAct      {S7_dynamic:='true'; S7_contact:='true'; S7_edit:='para'}
                : DigVal;        // 1 = Automatic mode active

    LoopClosed  {S7_visible:='false'; S7_dynamic:='true'; S7_contact:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_edit:='para'}
                : DigVal;        // 1 = Loop control is closed, 0 = Loop control is opened

    SP_ExtAct   {S7_dynamic:='true'; S7_contact:='true'}
                : DigVal;        // 1 = External setpoint active; 0 = Internal setpoint active
    AdvCoAct    {S7_visible:='false'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'} // S7_m_c because of OPC server
                : DigVal;        // 1 = Advanced control (program mode) active
    AdvCoRdy    {S7_visible:='false'}
                : DigVal;        // 1 = Controller ready for advanced control (program mode)

    CascaCut    {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1= Cascade connection cut, slave controller not prepared to accept SP_Ext

    SP          {S7_dynamic:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_xqc:='Value,true;'; S7_xtrend:='Value,PV_OpScale.Low,PV_OpScale.High;'; S7_edit:='para'}
                : AnaVal;        // Active setpoint as calculated and used by controller
    SP_ExtOut   {S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_dynamic:='true'}
                : AnaVal;        // External setpoint output

    SP_IntOut   {S7_m_c:= 'true'; S7_dynamic:='true'}
                : REAL :=0.0;        // Internal setpoint output

    SP_RateTarget {S7_visible:='false'; S7_m_c:='true'; S7_dynamic:='true'}
                : REAL := 0.0;   // Target  for limitation of setpoint gradients
    SP_RemRT    {S7_visible:='false'; S7_m_c:='true'; S7_dynamic:='true'}
                : REAL := 0.0;   // Remaining ramp time of setpoint

    SP_ExHiAct  {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = External setpoint high limit active
    SP_ExLoAct  {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = External setpoint low limit active
    SP_UpRaAct  {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = Positive rate limit of setpoint active
    SP_DnRaAct  {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = Negative rate limit of setpoint active

    SP_InHiOut  {S7_visible:='false'}
                : STRUCT
                  Value : REAL := 100.0;    // Value
                  ST    : BYTE := 16#80;    // Signal Status
                END_STRUCT;      // High limit for SP_Int, corresponds to input parameter SP_InHiLim
    SP_InLoOut  {S7_visible:='false'}
                : AnaVal;        // Low limit for SP_Int, corresponds to input parameter SP_InLoLim

    BypassAct   {S7_dynamic:='true'}
                :DigVal; // 1: Bypass is activated in this block

    PV_Out      {S7_xqc:='Value,true;'; S7_dynamic:='true'; S7_contact:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_xtrend:='Value,PV_OpScale.Low,PV_OpScale.High;'; S7_edit:='para'}
                : AnaVal;        // Process value (controlled variable) output
        StcAnaValPV_Out AT PV_Out : STRUCT
                Value : REAL;   // Value
                ST    : BYTE;   // Signal Status
                Bit0  : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                              END_STRUCT;

    PV_AH_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = PV alarm high active
        StcDigValPV_AH_Act AT PV_AH_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;
    PV_WH_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = PV warning high active
        StcDigValPV_WH_Act AT PV_WH_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;
    PV_TH_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = PV tolerance message high active
        StcDigValPV_TH_Act AT PV_TH_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;
    PV_TL_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = PV tolerance message low active
        StcDigValPV_TL_Act AT PV_TL_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;
    PV_WL_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = PV warning low active
        StcDigValPV_WL_Act AT PV_WL_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;
    PV_AL_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = PV alarm low active
        StcDigValPV_AL_Act AT PV_AL_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;

    PV_HysOut   {S7_visible:='false'}
                :REAL := 0.0; //PV - Alarm Hysteresis Output
    PV_AH_Out   {S7_visible:='false'}
                :REAL := 0.0; // PV - High Alarm Limit Output
    PV_WH_Out   {S7_visible:='false'}
                :REAL := 0.0; // PV - High Warning Limit Output
    PV_TH_Out   {S7_visible:='false'}
                :REAL := 0.0; // PV - High Tolerance Limit Output
    PV_TL_Out   {S7_visible:='false'}
                :REAL := 0.0; // PV - Low Tolerance Limit Output
    PV_WL_Out   {S7_visible:='false'}
                :REAL := 0.0; // PV - Low Warning Limit Output
    PV_AL_Out   {S7_visible:='false'}
                :REAL := 0.0; // PV - Low Alarm Limit Output
                                
    PV_ToleHi   {S7_visible:='false';S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_edit:='para'}
                : AnaVal;        // High limit of 3-sigma band around the setpoint (only with ConPerMon)
    PV_ToleLo   {S7_visible:='false';S7_m_c:= 'true'; S7_xm_c:='Value,true;'; S7_edit:='para'}
                : AnaVal;        // Low limit of 3-sigma band around the setpoint (only with ConPerMon)

    ER          {S7_dynamic:='true'; S7_m_c:= 'true'; S7_xm_c:='Value,true;'}
                : AnaVal;        // Control error
    ER_AH_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = ER  alarm high active
        StcDigValER_AH_Act AT ER_AH_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;
    ER_AL_Act   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = ER  alarm low active
        StcDigValER_AL_Act AT ER_AL_Act : STRUCT
                Value : BOOL;   // Value
                Bypass: BOOL;   // Hidden fill bit 1: Bypass active
                ST    : BYTE;   // Signal Status
                              END_STRUCT;
    ER_A_DCOut  {S7_visible:='false'}
                : REAL := 0.0;   // Effective Delay time for incoming ER alarms [s]

    FFwdHiAct   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = Feedforward high limit active
    FFwdLoAct   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // 1 = Feedforward low limit active

    SumMsgAct   {S7_visible:='false'; S7_dynamic:='true'}
                : DigVal;        // Summary message, 1 = Any of the process, external or system messages is active

    GainEff     {S7_visible:='false'}
                : REAL := 1.0;   // Effective proportional gain, depends on NegGain, Gain, NormPV and NormMV

    PV_UnitOut  {S7_visible:='false'}
                : INT := 0;      // Unit of measurement for process value, link to PV_Unit of ConPerMon block
    MV_UnitOut  {S7_visible:='false'}
                : INT := 0;      // Unit of measurement for manipulated var., link to MV_Unit of ConPerMon block

    P_Part      {S7_visible:='false'}
                : REAL := 0.0;   // P action of PID algorithm
    I_Part      {S7_visible:='false'}
                : REAL := 0.0;   // I action of PID algorithm
    D_Part      {S7_visible:='false'}
                : REAL := 0.0;   // D action of PID algorithm

    DynDeadBand {S7_dynamic:='true'}
                : REAL := 0.0;   // Dynamic deadband
    PhaseDeadBand {S7_dynamic:='true'}
          : INT:= 0;             // Phase of dynamic deadband adaptation, 0: DeadBand active, 1: DeadBand deactivated, 2: settling
    SettlingTimer{S7_dynamic:='true'}
                : REAL:= 0.0;    // Timer for settling of closed control loop

    ErrorNum    {S7_visible:='false'; S7_dynamic:='true'}
                : INT := INT#-1; // Error number, as defined in the online help

    Status1     {S7_visible:='false'; S7_dynamic:='true'; S7_m_c:='true'}
                : DWORD := 16#0; // Status word 1, defined in the online help
    Status2     {S7_visible:='false'; S7_dynamic:='true'; S7_m_c:='true'}
                : DWORD := 16#0; // Status word 2, defined in the online help
    Status3     {S7_visible:='false'; S7_dynamic:='true'; S7_m_c:='true'}
                : DWORD := 16#0; // Status word 3, defined in the online help

    Status4     {S7_visible:='false'; S7_dynamic:='true'}
                : DWORD := 16#0; // Status word 4, defined in the online help

    OS_PermOut  {S7_visible:='false'; S7_m_c:='true'}
                : DWORD := 16#FFFFFFFF; // Display of operator permissions OS_Perm
    OS_PermLog  {S7_visible:='false'; S7_m_c:='true'}
                : DWORD := 16#FFFFFFFF; // Operator permissions with settings changed by the block algorithm
    OS1PermOut  {S7_visible:='false'; S7_m_c:='true'}
                : DWORD := 16#FFFFFFFF; // Display of operator permissions OS1Perm
    OS1PermLog  {S7_visible:='false'; S7_m_c:='true'}
                : DWORD := 16#FFFFFFFF; // Operator permissions with settings changed by the block algorithm

    OpSt_Out    {S7_visible := 'false'; S7_m_c := 'true'}
                :DWORD := 16#0;  // Enabled operator stations

    ST_Worst    {S7_visible:='false'; S7_m_c:='true'}
                : BYTE := 16#80; // Worst signal status

    MsgErr1     {S7_visible:='false'}
                : BOOL := false; //1=Messaging error occurs
    MsgStat1    {S7_visible:='false'}
                : WORD := 16#0000;  //Message status
    MsgAckn1    {S7_visible:='false'}
                : WORD := 16#0000;     //Message acknowledgement status
    MsgErr2     {S7_visible:='false'}
                : BOOL := false; //1=Messaging error occurs
    MsgStat2    {S7_visible:='false'}
                : WORD := 16#0000;  //Message status
    MsgAckn2    {S7_visible:='false'}
                : WORD := 16#0000;     //Message acknowledgement status

    EnAcquireOut  {S7_visible := 'false'}
                  : BOOL; //Reserved
                                                       
    IsAcquired    {S7_visible := 'false'}
                  : BOOL; //Reserved
                      
    AfState       {S7_visible := 'false'; S7_contact := 'true'; S7_enum := 'ES_AcquireStates'}
                  : BYTE;  //Reserved
                                        
    AfReqPrev     {S7_visible := 'false'; S7_contact := 'true'}
                  : BYTE;  //Reserved
                    
    AfTimeStamp   {S7_visible := 'false'; S7_contact := 'true'}
                  : DINT;  //Reserved
                    
    AfWaitTmAct   {S7_visible := 'false'; S7_contact := 'true'}
                  : REAL;  //Reserved
                    
    StUnified     {S7_visible := 'false'; S7_enum := 'APL_UnifiedSt'}
                  : DWORD ; //Reserved
                  
 END_VAR


 VAR
  // Static Variables
  SrGain           : REAL := 0.0;   // Gain factor
  SrInvOld         : REAL := 0.0;   // Old input for integrator
  SrRestInt        : REAL := 0.0;   // Rest value in integrator
  SrRbkDev         : REAL := 0.0;   // Internal readback value
  SrRestDif        : REAL := 0.0;   // Rest value in the differentiator
  SrDiffSp         : REAL := 0.0;   // Difference setpoint
  SrSP_Int         : REAL := 0.0;   // Operator setpoint
  SrMan            : REAL := 0.0;   // Operator input for manual setting of manipulated variable MV
  SrSP_StartRmp    : REAL := 0.0;   // SP Ramp start value
  SrSP_RmpTarget   : REAL := 0.0;   // Setpoint ramp target
  SrRestSP_Rmp     : REAL := 0.0;   // Rest value in ramp function
  SrTimeFact       : REAL := 1.0;   // Time conversion factor into /Sec or /Min or /Hr.END_VAR

  SrPV_AH_OnTimer  : REAL := 0.0;   // Variable for on Timer for Alarm High
  SrPV_AH_OffTimer : REAL := 0.0;   // Variable for off Timer for Alarm High
  SrPV_WH_OnTimer  : REAL := 0.0;   // Variable for on Timer for Warning High
  SrPV_WH_OffTimer : REAL := 0.0;   // Variable for off Timer for Warning High
  SrPV_TH_OnTimer  : REAL := 0.0;   // Variable for on Timer for Tolerance High
  SrPV_TH_OffTimer : REAL := 0.0;   // Variable for off Timer for Tolerance High
  SrPV_AL_OnTimer  : REAL := 0.0;   // Variable for on Timer for Alarm Low
  SrPV_AL_OffTimer : REAL := 0.0;   // Variable for off Timer for Alarm Low
  SrPV_WL_OnTimer  : REAL := 0.0;   // Variable for on Timer for Warning Low
  SrPV_WL_OffTimer : REAL := 0.0;   // Variable for off Timer for Warning Low
  SrPV_TL_OnTimer  : REAL := 0.0;   // Variable for on Timer for Tolerance Low
  SrPV_TL_OffTimer : REAL := 0.0;   // Variable for off Timer for Tolerance Low

  SrPV_AH_DC       : REAL := 0.0;   // PV Alarm Delay Time Coming High [s]
  SrPV_AH_DG       : REAL := 0.0;   // PV Alarm Delay Time Going High [s]
  SrPV_WH_DC       : REAL := 0.0;   // PV Warning Delay Time Coming High [s]
  SrPV_WH_DG       : REAL := 0.0;   // PV Warning Delay Time Going High [s]
  SrPV_TH_DC       : REAL := 0.0;   // PV Tolerance Delay Time Coming High [s]
  SrPV_TH_DG       : REAL := 0.0;   // PV Tolerance Delay Time Going High [s]

  SrPV_A_DC        : REAL := 0.0;   // PV Alarm Delay Time Coming High/Low or only Low [s]
  SrPV_A_DG        : REAL := 0.0;   // PV Alarm Delay Time Going High/Low or only Low [s]
  SrPV_W_DC        : REAL := 0.0;   // PV Warning Delay Time Coming High/Low or only Low [s]
  SrPV_W_DG        : REAL := 0.0;   // PV Warning Delay Time Going High/Low or only Low [s]
  SrPV_T_DC        : REAL := 0.0;   // PV Tolerance Delay Time Coming High/Low or only Low [s]
  SrPV_T_DG        : REAL := 0.0;   // PV Tolerance Delay Time Going High/Low or only Low [s]

  SrER_AH_OnTimer  : REAL := 0.0;   // Variable for ER on Timer for High High alarm.
  SrER_AH_OffTimer : REAL := 0.0;   // Variable for ER off Timer for High High alarm.
  SrER_AL_OnTimer  : REAL := 0.0;   // Variable for ER on Timer for Low Low alarm.
  SrER_AL_OffTimer : REAL := 0.0;   // Variable for ER off Timer for Low Low alarm.
  SrER_AH_DC       : REAL := 0.0;   // ER Alarm Delay Time Coming High [s]
  SrER_AH_DG       : REAL := 0.0;   // ER Alarm Delay Time Going High [s]
  SrER_A_DC        : REAL := 0.0;   // ER Alarm Delay Time Coming High/Low or only Low [s]
  SrER_A_DG        : REAL := 0.0;   // ER Alarm Delay Time Going High/Low or only Low [s]
  SrER_AH_DFac     : REAL := 0.0;   // Old value ER_AH_DFac
  SrER_AL_DFac     : REAL := 0.0;   // Old value ER_AL_DFac

  SnRunUpCyc       : INT  := 0;     // Counter for RunUpCyc

  SdwBatchID       : DWORD:= 16#0;  // Old value of BatchID

  SxFirstStart     : BOOL := true;  // First start
  SxOosLi          : BOOL := false; // rising edge of OosLi
  SxSP_RmpOn       : BOOL := false; // Setpoint is ramped to SP_RmpTarget
  SxAdvCoMstrOn    : BOOL := false; // old value of AdvCoMstrOn
  SxDiffToFbk      : BOOL := false; // Old value of DiffToFbk
  SxD_PartInit     : BOOL := true;  // Initializing of D part

  SxConzExceeded   : BOOL := false; // Control zone exceeded

  SxFeat_SwiPoiFalseActOld  : BOOL := false; // Old value of Feature Bit29

  SxER_AH_Delay    :BOOL;  //ER High Alarm delay because of SP jump
  SxER_AL_Delay    :BOOL;  //ER Low Alarm delay because of SP jump

  SarBatchName : ARRAY[1..32] OF BYTE := 32(0); // batch name

  //Variable definition for reduced ALARM_8P calls - VV/WoP
  SbMsgEff1:              BYTE := 0;      //Effective message signal
  SaMsgEff1 AT SbMsgEff1 : ARRAY[1..8] OF BOOL;
  SbMsgEff1Old:           BYTE := 0;      //Effective message signal (Last cycle)
  SbMsgEff2:              BYTE := 0;      //Effective message signal
  SaMsgEff2 AT SbMsgEff2 : ARRAY[1..8] OF BOOL;
  SbMsgEff2Old:           BYTE := 0;      //Effective message signal (Last cycle)
  SnMsgToggle:            INT := 0;       //Reduce frequencey of call of ALARM_8P waiting for ACK
  SxShowAlarm1:           BOOL := TRUE;   //Call instance of ALARM_8P
  SxShowAlarm2:           BOOL := TRUE;   //Call instance of ALARM_8P
  //------------------------------------------------ VV/WoP

  SfbALARM_8P_1:   ALARM_8P;          // SFB 35
  SfbALARM_8P_2:   ALARM_8P;          // SFB 35

  _reserve        : ARRAY[0..15] OF BYTE;  // 16 bytes
    StcRes AT _reserve : STRUCT
            SrSP_RmpTime : REAL;      //Old value off SP_RmpTime
            ar_reserve   : ARRAY[4..15] OF BYTE;
                        END_STRUCT;

 END_VAR


 VAR_TEMP
  // Temporary Variables

  // structure of OB 100
  stcTOP_SI:      SSTartInf;
  stcSTART_UP_SI: SSTartInf;
  stcAnaVal : AnaVal;
  stcDigVal : DigVal;
        stcInitDigVal AT stcDigVal : STRUCT
                ByVal : BYTE;   // Value include fillbits
                ST    : BYTE;   // Signal Status
                                     END_STRUCT;

  rTemp1     : REAL;   // Temporary variable
  rTemp2     : REAL;   // Temporary variable
  rSp        : REAL;   // Setpoint
  rEr        : REAL;   // ER value from last cycle
  rPvOut     : REAL;   // PV_Out value from last cycle
  rSpTarget  : REAL;   // Target setpoint
  rSpDelt    : REAL;   // Difference between actual and old setpoint
  rGrade     : REAL;   // Grade setpoint rampe
  rSP_RmpTime  :REAL;  // Setpoint ramp time
  rSP_UpRaLim  :REAL;  // Upward rate limit of setpoint
  rSP_DnRaLim  :REAL;  // Downward rate limit of setpoint
  rSampleTime  : REAL; // Sample time
  rGain      : REAL;   // Gain factor
  rTi        : REAL;   // Integration time [s]
  rTd        : REAL;   // Differentiation time [s]
  rDiffGain  : REAL;   // Filter factor for derivative action [1..10]
  rPropFacSP : REAL;   // Proportional factor for setpoint changes [0..1]
  rTmLag     : REAL;   // Lag time [s]
  rErGain    : REAL;   // Difference (SP-PV)*Gain
  rI_Part    : REAL;   // I part
  rFFwd      : REAL;   // Additive part for feedforward MV, e.g. used for compensation of measurable disturbance variables
  rLmn       : REAL;   // manipulated variable
  rMan       : REAL;   // Manual value
  rDiff      : REAL;   // Difference value
  rDeadBand  : REAL;   // Dead band
  rConZone   : REAL;   // Control zone
  rSafePos   : REAL;   // MV safe position

  nTemp      : INT;    // Temporary variable, Error SFC/SFB call

  stcInST: STRUCT
       b0    : BYTE;
       b1    : BYTE;
       b2    : BYTE;
       b3    : BYTE;
       b4    : BYTE;
       b5    : BYTE;
       b6    : BYTE;
       b7    : BYTE;
       b8    : BYTE;
       b9    : BYTE;
      b10    : BYTE;
      b11    : BYTE;
      b12    : BYTE;
      b13    : BYTE;
      b14    : BYTE;
      b15    : BYTE;
          END_STRUCT;              // Input 0..15 Signal Status


  dwStatus1  : DWORD;  // Local copy of Status
  strStatus1 AT dwStatus1 :  SBits32inDWORD;
  dwStatus2  : DWORD;  // Local copy of Status
  strStatus2 AT dwStatus2 :  SBits32inDWORD;
  dwStatus3  : DWORD;  // Local copy of Status
  strStatus3 AT dwStatus3 :  SBits32inDWORD;
  arbyStatusWord3 AT dwStatus3:  ARRAY[0..3] OF BYTE;
  dwStatus4  : DWORD; //Variable for status4
  strStatus4 AT dwStatus4:  SBits32inDWORD;         //Auxiliary struct with pointer to dwStatus4 for shift state bits
  arbyStatusWord4 AT dwStatus4:  ARRAY[0..3] OF BYTE;
  wEventTsIn : WORD;
  arrbyEventTsIn AT wEventTsIn: ARRAY[0..1] OF BYTE;
  wTranferData :    WORD;                                 //Tranfer data between techn. block and EventTs

  EvtTs_Mode: STRUCT
      Connected : BOOL;
      MS_Release : BOOL;
      MsgLock : BOOL;
      OosAct : BOOL;
      BatchEn : BOOL;
      Occupied : BOOL;
      Bit6 : BOOL;
      Bit7 : BOOL;
      Bit8 : BOOL;
      Bit9 : BOOL;
      Bit10 : BOOL;
      Bit11 : BOOL;
      Bit12 : BOOL;
      Bit13 : BOOL;
      Bit14 : BOOL;
      Bit15 : BOOL;
  END_STRUCT;   // EventTs Mode bits
  atEvtTs_Mode AT EvtTs_Mode : WORD;

  diOffset : DINT;
  tempANY : ANY;
  attempANY AT tempANY : Struct_ANY;

  dwOS_Perm : DWORD;
  arrdwOS_Perm AT dwOS_Perm : ARRAY[0..3] OF BYTE;
  stcdwOS_Perm AT dwOS_Perm: STRUCT
     Bit24: BOOL;
     Bit25: BOOL;
     Bit26: BOOL;
     Bit27: BOOL;
     Bit28: BOOL;
     Bit29: BOOL;
     Bit30: BOOL;
     Bit31: BOOL;

     Bit16: BOOL;
     Bit17: BOOL;
     Bit18: BOOL;
     Bit19: BOOL;
     Bit20: BOOL;
     Bit21: BOOL;
     Bit22: BOOL;
     Bit23: BOOL;

     Bit8: BOOL;
     Bit9: BOOL;
     Bit10: BOOL;
     Bit11: BOOL;
     Bit12: BOOL;
     Bit13: BOOL;
     Bit14: BOOL;
     Bit15: BOOL;

     Bit0: BOOL;
     Bit1: BOOL;
     Bit2: BOOL;
     Bit3: BOOL;
     Bit4: BOOL;
     Bit5: BOOL;
     Bit6: BOOL;
     Bit7: BOOL;
  END_STRUCT;

  xOpenLoop         :BOOL;  //Tracking, manual or forced mode
  xSP_TrkPV         :BOOL;  //SP tracks PV in manual and tracking mode
  xHiAct            :BOOL;  //Internal setpoint high limit is active
  xLoAct            :BOOL;  //Internal setpoint low limit is active
  xRampAct          :BOOL;  //Ramp is active
  xRampRes          :BOOL;  //Ramp will be reset
  xConzExceeded     :BOOL;  //Control zone exceeded (current cycle)
  xSimAct           :BOOL;  //simulation active
  xRstER_AH_Delay   :BOOL;  //reset ER Alarm Delay because of SP jump
  xRstER_AL_Delay   :BOOL;  //reset ER Alarm Delay because of SP jump

  xInvalidMode      :BOOL;  //Variable for Invalid mode

  xIntlock_N:BOOL;          //1 = Valve is interlocked
  xIntl_En:BOOL;            //Intlock enabled

  xFeat_StartupWithOutInit : BOOL;
  xFeat_OosLiEn:             BOOL;
  xFeat_ResetInLi:           BOOL;
  xFeat_OnlyActPos:          BOOL;
  xFeat_SafePosStartOn:      BOOL;
  xFeat_ER_ExternOn:         BOOL;
  xFeat_SafePosOOS_On:       BOOL;
  xFeat_AutWithP_Part:       BOOL;
  xFeat_SwiPoiDis:           BOOL;
  xFeat_SwiPoiFalseAct:      BOOL;
  xFeatSpTrkPvNoPrio:        BOOL;
  xFeat_SubValAct:           BOOL;  // Bit 9 = 1, Substitution value is activ if block is in bypass
  xFeatGradDuration:         BOOL;  // Bit 11 = 1  Gradient limitation with time duration
  xFeatLocalAuth:            BOOL;  // Bit 24 = 1, Function local authorization active
  xFeatMsgLockAll:           BOOL;
  xFeatSwiPoiOOS:            BOOL;  // Bit 26 = 1, 1 = Reset switching points if switching to Out of Service
  xFeat_ConZoneI_MVoffset:   BOOL;
  xFeat_ConZoneI_Frozen:     BOOL;
  xFeatDeadBandAdaption:     BOOL;  // Bit 30, 1 = apply Deadband adaption
  xFeatRmpActStartPoint:     BOOL;  // Bit 6 = 1,Ramp rate is calculated with actual start point and actual ramp target value
  xFeature_SepDelTime:       BOOL;  // Separate delay times for each alarm
  xFeatBypass:               BOOL;  //Feature2.Bit 2, 1 = Separate evaluation OF bypassed AND simulated interlock signals
  xFeatIgnrBadIntlkState:    BOOL;  //Feature2.Bit 5, 1 = Ignore bad signal state in interlock signals
  xFeatSuppMsgLckOOS:        BOOL;  //Feature2.Bit 11, 1 = Suppress MsgLock and "Out of service" for connected message block
  XFeat_SSinOOS:             BOOL;  //Feature.Bit 5, 1 = changes signal status of  all applicable outputs to 16#60 in OOS
  xFeat_LimitsDisabled:      BOOL;  //Bit 31 = 1, Limits disabled in faceplate
  
  //1755853 : APL general use of limit values - out-greyed limit values 
  xOS1_Perm_PV_AH_Lim:       BOOL;  // 1 = Operator can change the process value high alarm limit PV_AH_Lim
  xOS1_Perm_PV_AL_Lim:       BOOL;  // 1 = Operator can change the process value high alarm limit PV_AL_Lim.
  xOS1_Perm_PV_WH_Lim:       BOOL;  // 1 = Operator can change the process value high alarm limit PV_WH_Lim
  xOS1_Perm_PV_WL_Lim:       BOOL;  // 1 = Operator can change the process value high alarm limit PV_WL_Lim
  xOS1_Perm_PV_TH_Lim:       BOOL;  // 1 = Operator can change the process value high alarm limit PV_TH_Lim
  xOS1_Perm_PV_TL_Lim:       BOOL;  // 1 = Operator can change the process value high alarm limit PV_TL_Lim
  xOS1_Perm_ER_AH_Lim:       BOOL;  // 1 = Operator can change the control error high alarm limit ER_AH_Lim
  xOS1_Perm_ER_AL_Lim:       BOOL;  // 1 = Operator can change the control error high alarm limit ER_AL_Lim
  xOS1_Perm_RBK_WH_Lim:      BOOL;  // 1 = Operator can change the position feedback high warning limit RbkWH_Lim
  xOS1_Perm_RBK_WL_Lim:      BOOL;  // 1 = Operator can change the position feedback high warning limit RbkWH_Lim
  xOS1_Perm_PV_Hyst:         BOOL;  // 1 = Operator can change the process value hysteresis PV_Hyst  
  xOS1_Perm_ER_Hyst:         BOOL;  // 1 = Operator can change the process value hysteresis ER_Hyst
  xOS1_Perm_RbkHyst:         BOOL;  // 1 = Operator can change the process value hysteresis RbkHyst
  
  // ------ Reading OB Start Information
  xOB_Cycle                 :BOOL;  //block is running in a cyclic interrupt OB
  xOB_Start                 :BOOL;  //block is running in start OB

 END_VAR


 BEGIN
    // Instruction Section
    xInvalidMode := false;

    stcInitDigVal.ByVal := 16#0; //Value with fill bits
    stcDigVal.ST    := 16#80;

    // copy status parameters to temporary variables
    dwStatus1 := Status1;
    dwStatus2 := Status2;
    dwStatus3 := Status3;
    dwStatus4 := Status4;
    // copy input parameters to temporary variables
    xFeat_StartupWithOutInit := Feature.Bit0;
    xFeat_OosLiEn            := Feature.Bit1;
    xFeat_ResetInLi          := Feature.Bit2;
    xFeat_OnlyActPos         := Feature.Bit4;
    XFeat_SSinOOS            := Feature.Bit5;
    xFeatRmpActStartPoint    := Feature.Bit6;
    xFeature_SepDelTime      := Feature.Bit8;
    xFeat_SubValAct          := Feature.Bit9;
    xFeatGradDuration        := Feature.Bit11;
    xFeat_ConZoneI_MVoffset  := Feature.Bit12;
    xFeat_ConZoneI_Frozen    := Feature.Bit13;
    xFeat_ER_ExternOn        := Feature.Bit14;
    xFeat_SafePosStartOn     := Feature.Bit16;
    xFeat_SafePosOOS_On      := Feature.Bit15;
    xFeat_AutWithP_Part      := Feature.Bit18;
    xFeatSpTrkPvNoPrio       := Feature.Bit23;
    xFeat_SwiPoiDis          := Feature.Bit28;
    xFeat_SwiPoiFalseAct     := Feature.Bit29;
    xFeatLocalAuth           := Feature.Bit24;
    xFeatMsgLockAll          := Feature.Bit25;
    xFeatSwiPoiOOS           := Feature.Bit26;
    xFeatDeadBandAdaption    := Feature.Bit30;
    xFeatBypass              := Feature2.Bit2;
    xFeatIgnrBadIntlkState   := Feature2.Bit5;
    xFeatSuppMsgLckOOS       := Feature2.Bit11;
    xFeat_LimitsDisabled     := Feature.Bit31;
    
    //1755853 : APL general use of limit values - out-greyed limit values 
    xOS1_Perm_PV_AH_Lim       := OS1Perm.Bit0;
    xOS1_Perm_PV_AL_Lim       := OS1Perm.Bit6;
    xOS1_Perm_PV_WH_Lim       := OS1Perm.Bit1;
    xOS1_Perm_PV_WL_Lim       := OS1Perm.Bit5;
    xOS1_Perm_PV_TH_Lim       := OS1Perm.Bit2;
    xOS1_Perm_PV_TL_Lim       := OS1Perm.Bit4;   
    xOS1_Perm_ER_AH_Lim       := OS1Perm.Bit7;
    xOS1_Perm_ER_AL_Lim       := OS1Perm.Bit9;    
    xOS1_Perm_RBK_WH_Lim      := OS1Perm.Bit10;     
    xOS1_Perm_RBK_WL_Lim      := OS1Perm.Bit12;      
    xOS1_Perm_PV_Hyst         := OS1Perm.Bit3; 
    xOS1_Perm_ER_Hyst         := OS1Perm.Bit8; 
    xOS1_Perm_RbkHyst         := OS1Perm.Bit11; 
    
    //Simulation active
    xSimAct := SimOn AND NOT SimLiOp.Value OR SimOnLi.Value AND SimLiOp.Value;

    // ------ Reading OB Start Information
    nTemp := RD_SINFO (TOP_SI := stcTOP_SI, START_UP_SI := stcSTART_UP_SI);
    xOB_Cycle := (BYTE_TO_INT(stcTOP_SI.NUM) >= C_OB_CYCLIC_MIN ) AND ( BYTE_TO_INT(stcTOP_SI.NUM) <= C_OB_CYCLIC_MAX );
    xOB_Start := BYTE_TO_INT(stcTOP_SI.NUM) = C_OB_START;

    ErrorNum := C_ERROR_NO; //No Error

    // Safety position
    IF SafePos2 =0
    THEN
        IF SafePos
        THEN
            rSafePos := ManHiLim;
        ELSE
            rSafePos := ManLoLim;
        END_IF;
    ELSIF SafePos2 =1
    THEN
        rSafePos := MV_SafePos.Value;
    ELSE
        rSafePos := MV.Value;//Stop
    END_IF;

    rEr := ER.Value;
    rPvOut := PV_Out.Value;


    //Set temporary variables for interlock
    xIntl_En := Intl_En AND NOT (Intlock.ST = 16#FF);
    
    IF xFeatIgnrBadIntlkState THEN
    xIntlock_N := (NOT Intlock.Value) AND xIntl_En;
    ELSE
    xIntlock_N := (NOT Intlock.Value OR (Intlock.ST = 16#00) OR (Intlock.ST = 16#28)) AND xIntl_En;
    END_IF;

    //Reset the fill bit if the input is not connected or bypass featurebit is off
    IF Intlock.ST = 16#FF OR Not xFeatBypass THEN StcDigValIntlock.Bypass := false; END_IF;

    tempANY := SarBatchName; //Get ANY pointer on saved BA_NA value

    //help vars for Ramp in MV_RateOn and MV_RmpOn
    xRampAct := false;
    xRampRes := false;

//_______________________________________________________________________________________________________________________________________________________
//
//Module 1: MS Release / Out Of Service / Local authorisation

    //MS Release
    MS_Release.Value := MS_RelOp AND (ManAct.Value OR OosAct.Value) AND NOT MV_ForOn.Value;
    IF NOT (ManAct.Value OR OosAct.Value) OR MV_ForOn.Value
    THEN
        MS_RelOp := false;
    END_IF;

    //Local authorisation
    IF xFeatLocalAuth THEN
        OpSt_Out := OpSt_In OR 16#80000000;
    ELSE
        OpSt_Out := OpSt_In AND 16#7FFFFFFF;
    END_IF;

    //Switch between "Out of service" and Manual mode
     IF OosAct.Value OR ManAct.Value
    THEN
        // Use operator inputs to set "Out Of Service"/Manual mode
        IF ManModOp
        THEN
            ManAct.Value := true;
            OosAct.Value := false;
            IF XFeat_SSinOOS THEN
                SP_ExtAct.ST := 16#80;           
            END_IF;     
        ELSIF OosOp  OR (OosLi.Value AND xFeat_OosLiEn AND NOT SxOosLi)
        THEN
            IF xFeat_SafePosOOS_On
            THEN
                // Safety position
                Man := rSafePos;
                MV.Value := Man;
                SrMan := Man;
            END_IF;
            ManAct.Value := false;
            OosAct.Value := true;
            IF xFeat_SSinOOS THEN
                RbkOut.ST := 16#60;
                RbkWH_Act.ST := 16#60;
                RbkWL_Act.ST := 16#60;            
                SP_ExtAct.ST := 16#60;  
                SP_ExtOut.ST := 16#60;          
                SP.ST        := 16#60;            
                PV_Out.ST    := 16#60;
                PV_AH_Act.ST := 16#60;
                PV_WH_Act.ST := 16#60;
                PV_TH_Act.ST := 16#60;
                PV_TL_Act.ST := 16#60;
                PV_WL_Act.ST := 16#60;
                PV_AL_Act.ST := 16#60;
                PV_ToleHi.ST := 16#60;
                PV_ToleLo.ST := 16#60;
                ER.ST        := 16#60;
                ER_AH_Act.ST := 16#60;
                ER_AL_Act.ST := 16#60;     
            ELSE                
                SP.ST        := 16#80;                               
                PV_Out.ST    := 16#80;
                IF Rbk.ST = 16#FF THEN
                    RbkOut.ST := 16#FF;
                ELSE   
                    RbkOut.ST := 16#80;
                END_IF;     
                 IF xFeatSwiPoiOOS  THEN
                    PV_AH_Act.ST   := 16#80;
                    PV_WH_Act.ST   := 16#80;
                    PV_TH_Act.ST   := 16#80;
                    PV_TL_Act.ST   := 16#80;
                    PV_WL_Act.ST   := 16#80;
                    PV_AL_Act.ST   := 16#80;
                    ER_AH_Act.ST   := 16#80;
                    ER_AL_Act.ST   := 16#80;
                    RbkWH_Act.ST   := 16#80;
                    RbkWL_Act.ST   := 16#80;
                 END_IF;
            END_IF;  
            //resert group error and ready to start
            GrpErr      := stcDigVal;
            RdyToStart  := stcDigVal;

        END_IF;
        AutAct.Value := NOT ManAct.Value AND NOT OosAct.Value;

        // edge SxOosLi -> OosLi.Value only a rising edge cause  OOS to the block
        SxOosLi := OosLi.Value;

    END_IF; // IF OosAct.Value OR ManAct.Value
    //reset parameter ManModOp := false; OosOp := false;
    //look at the end of OOS routine

    IF OosAct.Value
    THEN
        //resert group error and ready to start
        //GrpErr      := stcDigVal;
        RdyToStart  := stcDigVal;
        IF xFeatSwiPoiOOS  THEN
            PV_AH_Act.Value   := False;
            PV_WH_Act.Value   := False;
            PV_TH_Act.Value   := False;
            PV_TL_Act.Value   := False;
            PV_WL_Act.Value   := False;
            PV_AL_Act.Value   := False;
            ER_AH_Act.Value   := False;
            ER_AL_Act.Value   := False;
            RbkWH_Act.Value   := False;
            RbkWL_Act.Value   := False;                 
            IF xFeat_SwiPoiFalseAct THEN
                PV_AH_Act.Value := true;
                PV_WH_Act.Value := true;
                PV_TH_Act.Value := true;
                PV_TL_Act.Value := true;
                PV_WL_Act.Value := true;
                PV_AL_Act.Value := true;
                ER_AH_Act.Value := true;
                ER_AL_Act.Value := true;
                RbkWH_Act.Value := true;
                RbkWL_Act.Value := true;
            END_IF;
        END_IF;
        

        ST_Worst := 16#80;        
        MV.ST := 16#80;
    END_IF; //IF OosAct.Value THEN


//_________________________________________________________________________________________________________________________________________________
//
//Module 2: StartUp Characteristics

    //Start up routines ------------------------------------------------------
    IF SxFirstStart OR xOB_Start THEN            //Initial Start/Reset/Restart

        //Initialization.

        SxFirstStart := FALSE;
        SxShowAlarm1 := TRUE; //VV
        SxShowAlarm2 := TRUE; //VV

        IF xOB_Start THEN
            SnRunUpCyc := RunUpCyc; // Store the value of the RUNUPCYC entrance
        END_IF;
        PhaseDeadBand:= 0;

        // set default startup characteristics of the block

        IF NOT xFeat_StartupWithoutInit
        THEN

            stcAnaVal.Value := 0.0;
            stcAnaVal.ST    := 16#80;

            //resert group error and ready to start
            GrpErr      := stcDigVal;
            RdyToStart  := stcDigVal;

            // Output Variables
            MV          := stcAnaVal;        // Manipulated Variable, Control Output
            MV_HiAct    := stcDigVal;        // MV high limit is actively restricting manipulated variable
            MV_LoAct    := stcDigVal;        // MV low limit is actively restricting manipulated variable

            ManHiOut.Value := 100.0;         // High limit for Man
            ManHiOut.ST := 16#80;
            ManLoOut    := stcAnaVal;        // Low limit for Man

            RbkOut      := stcAnaVal;        // Readback Value, Control Output
            RbkWH_Act   := stcDigVal;        // Rbk - Warning High Active
            RbkWL_Act   := stcDigVal;        // Rbk - Warning Low Active
            MS_Release.Value  := false;            // 1: MS release
            AutAct      := stcDigVal;        // Automatic (PID algorithm) mode is active
            LoopClosed  := stcDigVal;        // Loop control is closed
            ManAct.Value := true;         // Manaul value is active
            ManAct.ST    := 16#80;        // Manaul value is active
            AdvCoAct    := stcDigVal;        // Advanced control (program mode) active
            AdvCoRdy    := stcDigVal;        // Controller ready for advanced control
            OosAct      := stcDigVal;        // Out Of Service is active
            SP_ExtAct   := stcDigVal;        // 1: External setpoint is active, 0: Internal setpoint is active
            CascaCut    := stcDigVal;        // Cascade connection; 1: Loop control is open

            SP          := stcAnaVal;        // Active setpoint as calculated and used by controller
            SP_ExtOut   := stcAnaVal;        // External setpoint output
            SP_IntOut   := 0.0;              // Internal setpoint output

            SP_ExHiAct  := stcDigVal;        // External setpoint high limit is active
            SP_ExLoAct  := stcDigVal;        // External setpoint low limit is active
            SP_UpRaAct  := stcDigVal;        // Setpoint positive rate limit is active
            SP_DnRaAct  := stcDigVal;        // Setpoint negative rate limit is active

            SP_InHiOut.Value := 100.0;       // High limit for SP_Int
            SP_InHiOut.ST  := 16#80;
            SP_InLoOut  := stcAnaVal;        // Low limit for SP_Int

            PV_Out      := stcAnaVal;        // Process value (controlled variable) Output

            PV_AH_Act   := stcDigVal;        // PV - Alarm High Active
            PV_WH_Act   := stcDigVal;        // PV - Warning High Active
            PV_TH_Act   := stcDigVal;        // PV - Tolerance High Active
            PV_TL_Act   := stcDigVal;        // PV - Tolerance Low Active
            PV_WL_Act   := stcDigVal;        // PV - Warning Low Active
            PV_AL_Act   := stcDigVal;        // PV - Alarm Low Active

            PV_HysOut   := PV_Hyst;          // PV - Alarm Hysteresis Output
            PV_AH_Out   := PV_AH_Lim;        // PV - High Alarm Limit Output
            PV_WH_Out   := PV_WH_Lim;        // PV - High Warning Limit Output
            PV_TH_Out   := PV_TH_Lim;        // PV - High Tolerance Limit Output
            PV_TL_Out   := PV_TL_Lim;        // PV - Low Tolerance Limit Output
            PV_WL_Out   := PV_WL_Lim;        // PV - Low Warning Limit Output
            PV_AL_Out   := PV_AL_Lim;        // PV - Low Alarm Limit Output
            
            ER          := stcAnaVal;        // Control Error, Deviation
            ER_AH_Act   := stcDigVal;        // ER - Alarm High  Active
            ER_AL_Act   := stcDigVal;        // ER - Low Low Alarm Active
            IF xFeature_SepDelTime THEN
                ER_A_DCOut  := 0.0;
            ELSE 
                ER_A_DCOut  := ER_A_DC;
            END_IF;

            FFwdHiAct   := stcDigVal;        // Feedforward MV high limit is active
            FFwdLoAct   := stcDigVal;        // Feedforward MV low limit is active

            SumMsgAct   := stcDigVal;        // Summery message

            IF xFeat_SwiPoiFalseAct THEN     //limit outputs are 0-active and must be set
                PV_AH_Act.Value := true;
                PV_WH_Act.Value := true;
                PV_TH_Act.Value := true;
                PV_TL_Act.Value := true;
                PV_WL_Act.Value := true;
                PV_AL_Act.Value := true;
                ER_AH_Act.Value := true;
                ER_AL_Act.Value := true;
                RbkWH_Act.Value := true;
                RbkWL_Act.Value := true;
            END_IF;

            GainEff     := 1.0;   // Effective Proportional Gain; dependent on NormPV.High, NormPV.Low, NormMV.High and NormMV.Low

            P_Part      := 0.0;   // P part of PID algorithm
            I_Part      := MV_Offset;   // I part of PID algorithm
            D_Part      := 0.0;   // D part of PID algorithm

            Status1     := 16#0; // Status Word 1, defined in the online help
            Status2     := 16#0; // Status Word 2, defined in the online help
            Status3     := 16#0;   // Status Word 3, defined in the online help
            Status4     := 16#0;   // Status Word 3, defined in the online help

            OS_PermOut  := 16#FFFFFFFF; // Operator permissions OS_Perm
            OS_PermLog  := 16#FFFFFFFF; // Operator permissions OS_Perm with changes from FB algorithm
            OS1PermOut  := 16#FFFFFFFF; // Operator permissions OS1Perm
            OS1PermLog  := 16#FFFFFFFF; // Operator permissions OS1Perm with changes from FB algorithm

            ST_Worst    := 16#80; // Worst Quality Code

            MsgErr1     := false; // ALARM_8P: Error Output
            MsgStat1    := 16#0;  // ALARM_8P: Status Output
            MsgAckn1    := 0;     // ALARM_8P: ACK_STATE Output
            MsgErr2     := false; // ALARM_8P: Error Output
            MsgStat2    := 16#0;  // ALARM_8P: Status Output
            MsgAckn2    := 0;     // ALARM_8P: ACK_STATE Output

            // Static Variables
            SrGain           := 0.0;   // Gain factor
            SrInvOld         := 0.0;   // Old input for integrator
            SrRestInt        := 0.0;   // Rest value in integrator
            SrRbkDev         := 0.0;   // Internal readback value
            SrRestDif        := 0.0;   // Rest value in the differentiator
            SrDiffSp         := 0.0;   // Difference setpoint
            SrSP_Int         := SP_Int;   // Operator setpoint
            SrMan            := Man;   // Operator input for manual setting of manipulated variable MV
            SrSP_StartRmp    := 0.0;   // SP Ramp start value
            SrSP_RmpTarget   := SP_RmpTarget;   // Setpoint ramp target
            SrRestSP_Rmp     := 0.0;   // Rest value in ramp function

            SrPV_AH_OnTimer  := 0.0;   // Variable for on Timer for Alarm High
            SrPV_AH_OffTimer := 0.0;   // Variable for off Timer for Alarm High
            SrPV_WH_OnTimer  := 0.0;   // Variable for on Timer for Warning High
            SrPV_WH_OffTimer := 0.0;   // Variable for off Timer for Warning High
            SrPV_TH_OnTimer  := 0.0;   // Variable for on Timer for Tolerance High
            SrPV_TH_OffTimer := 0.0;   // Variable for off Timer for Tolerance High
            SrPV_AL_OnTimer  := 0.0;   // Variable for on Timer for Alarm Low
            SrPV_AL_OffTimer := 0.0;   // Variable for off Timer for Alarm Low
            SrPV_WL_OnTimer  := 0.0;   // Variable for on Timer for Warning Low
            SrPV_WL_OffTimer := 0.0;   // Variable for off Timer for Warning Low
            SrPV_TL_OnTimer  := 0.0;   // Variable for on Timer for Tolerance Low
            SrPV_TL_OffTimer := 0.0;   // Variable for off Timer for Tolerance Low
            SrPV_A_DC        := 0.0;   // PV Alarm Delay Time Coming [s]
            SrPV_A_DG        := 0.0;   // PV Alarm Delay Time Going [s]
            SrPV_W_DC        := 0.0;   // PV Warning Delay Time Coming [s]
            SrPV_W_DG        := 0.0;   // PV Warning Delay Time Going [s]
            SrPV_T_DC        := 0.0;   // PV Tolerance Delay Time Coming [s]
            SrPV_T_DG        := 0.0;   // PV Tolerance Delay Time Going [s]

            SrER_AH_OnTimer  := 0.0;   // Variable for ER on Timer for High High alarm.
            SrER_AH_OffTimer := 0.0;   // Variable for ER off Timer for High High alarm.
            SrER_AL_OnTimer  := 0.0;   // Variable for ER on Timer for Low Low alarm.
            SrER_AL_OffTimer := 0.0;   // Variable for ER off Timer for Low Low alarm.
            SrER_A_DC        := 0.0;   // ER Alarm Delay Time Coming [s]
            SrER_A_DG        := 0.0;   // ER Alarm Delay Time Going [s]
            SrER_AH_DFac     := 0.0;   // Old value ER_AH_DFac
            SrER_AL_DFac     := 0.0;   // Old value ER_AL_DFac

            //SnRunUpCyc       := 0;     // Counter for RunUpCyc

            SdwBatchID       := 16#0;  // Old value of BatchID

            //SxFirstStart     := true;  // First start
            SxOosLi          := false;          // rising edge of OosLi
            SxSP_RmpOn       := false; // Setpoint is ramped to SP_RmpTarget
            SxDiffToFbk      := false; // Old value of DiffToFbk
            //SxD_PartInit     := true;  // Initializing of D part

            SxConzExceeded   := false; // Control zone exceeded
            SxFeat_SwiPoiFalseActOld := xFeat_SwiPoiFalseAct; // Old value of Feature Bit29
            SxAdvCoMstrOn    := AdvCoMstrOn.Value; // old value of AdvCoMstrOn

            FOR nTemp := 1 TO 32
             DO
                SarBatchName[nTemp] := 0;
            END_FOR;

            // Input Variables

            //switch to operator manual mode
            AutModOp := false;
            IF ModLiOp.Value
            THEN
                ManModOp  := false;
            ELSE
                ManModOp  := true;
            END_IF;

            // Safety position
            IF xFeat_SafePosStartOn
            THEN
                Man := rSafePos;
            END_IF;

            //Turn off optimization
            OptimEn := false;
            OptimOcc := false;

        END_IF; //IF stcFeatures.xStartupWithoutInit

        SxD_PartInit  := true; // Initializing of D part
        
    END_IF; //IF SxFirstStart OR xOB_Start THEN

    IF NOT OosAct.Value AND xOB_Cycle
    THEN
        //cyclic interrupts algorithm

        //Check Process Value ----------------------------------------------------------

        //Check PV_In
        PV.Value := ChkReal(In := PV.Value, ErrNum := nTemp);
        IF (nTemp=1 OR nTemp=3) THEN ErrorNum := C_ERROR_NUM_PV; END_IF;
        //Check SP_Ext
        SP_Ext.Value := ChkReal(In := SP_Ext.Value, ErrNum := nTemp);
        IF (nTemp=1 OR nTemp=3) THEN ErrorNum := C_ERROR_NUM_SPEXT; END_IF;
        //Check FFwd
        FFwd.Value := ChkReal(In := FFwd.Value, ErrNum := nTemp);
        IF (nTemp=1 OR nTemp=3) THEN ErrorNum := C_ERROR_NUM_MVFEFORW; END_IF;
        //Check MV_Trk
        MV_Trk.Value := ChkReal(In := MV_Trk.Value, ErrNum := nTemp);
        IF (nTemp=1 OR nTemp=3) THEN ErrorNum := C_ERROR_NUM_MVTRACK; END_IF;
        //Check MV_Byp
        MV_Forced.Value := ChkReal(In := MV_Forced.Value, ErrNum := nTemp);
        IF (nTemp=1 OR nTemp=3) THEN ErrorNum := C_ERROR_NUM_MVFORCED; END_IF;
        //Check RbkMV
        Rbk.Value := ChkReal(In := Rbk.Value, ErrNum := nTemp);
        IF (nTemp=1 OR nTemp=3) THEN ErrorNum := C_ERROR_NUM_RBK; END_IF;

        IF ErrorNum = C_ERROR_NO
        THEN

            //Initialization

            //Check Feature.Bit29 wether it changed //1= Output value =0 if limit is reached
            IF xFeat_SwiPoiFalseAct XOR SxFeat_SwiPoiFalseActOld THEN
                PV_AH_Act.Value := NOT PV_AH_Act.Value;
                PV_WH_Act.Value := NOT PV_WH_Act.Value;
                PV_TH_Act.Value := NOT PV_TH_Act.Value;
                PV_TL_Act.Value := NOT PV_TL_Act.Value;
                PV_WL_Act.Value := NOT PV_WL_Act.Value;
                PV_AL_Act.Value := NOT PV_AL_Act.Value;
                ER_AH_Act.Value := NOT ER_AH_Act.Value;
                ER_AL_Act.Value := NOT ER_AL_Act.Value;
                RbkWH_Act.Value := NOT RbkWH_Act.Value;
                RbkWL_Act.Value := NOT RbkWL_Act.Value;
            END_IF;
            SxFeat_SwiPoiFalseActOld := xFeat_SwiPoiFalseAct;

            //parameter limitations-------------------------------------------

            //Allowed range: SampleTime >= 0.001
            rSampleTime := SampleTime;
            IF SampleTime < 0.001
            THEN
                rSampleTime := 0.001;
            END_IF;

            //Gain Limitation
            IF SrGain < 0.0
            THEN
                SrGain := 0.0;
            END_IF;

            IF Gain.Value < 0.0
            THEN
                rGain := SrGain;
                ErrorNum := C_ERROR_NEGGAIN;
            ELSE
                rGain := Gain.Value;
            END_IF;
            SrGain := rGain;

            //Reverse Gain
            IF NegGain.Value
            THEN
                rGain := -rGain;
            END_IF;

            //Allowed range: |TI| >= SampleTime/2
            rTi := TI.Value;
            IF ABS(rTi) < rSampleTime * 0.5
            THEN
                IF rTi < 0
                THEN
                    rTi := -rSampleTime * 0.5;
                ELSE;
                    rTi := rSampleTime * 0.5;
                END_IF;
                IF TI.Value <> 0.0
                THEN
                    ErrorNum := C_ERROR_TI;
                END_IF;
            END_IF;

            //Allowed range: |TD| >= SampleTime
            rTd := TD.Value;
            IF ABS(rTd) < rSampleTime
            THEN
                IF rTd < 0
                THEN
                    rTd := -rSampleTime;
                ELSE;
                    rTd := rSampleTime;
                END_IF;
                IF TD.Value <> 0.0
                THEN
                    ErrorNum := C_ERROR_TD;
                END_IF;
            END_IF;

            //Allowed range: 1.0<=DiffGain<=10.0
            rDiffGain := DiffGain.Value;
            IF DiffGain.Value < 1.0
            THEN
                rDiffGain := 1.0;
                ErrorNum := C_ERROR_DIFFGAIN;
            END_IF;
            IF DiffGain.Value > 10.0
            THEN
                rDiffGain := 10.0;
                ErrorNum := C_ERROR_DIFFGAIN;
            END_IF;

            //Allowed range: TD/DiffGain >= SampleTime/2
            rTmLag := rTd/rDiffGain;
            IF rTmLag < rSampleTime * 0.5
            THEN
                rTmLag := rSampleTime * 0.5;
                IF TD.Value <> 0.0
                THEN
                    ErrorNum := C_ERROR_TD_DIFFGAIN;
                END_IF;
            END_IF;

            //Allowed range: 0.0 <= PropFacSP <= 1.0
            rPropFacSP := PropFacSP;
            IF PropFacSP > 1.0 THEN
                rPropFacSP := 1.0;
                ErrorNum := C_ERROR_PROPFACSP;
            ELSIF PropFacSP < 0.0 THEN
                rPropFacSP := 0.0;
                ErrorNum := C_ERROR_PROPFACSP;
            END_IF;

            // Set/Reset Bypass
            IF BypLiOp.Value THEN 
                IF BypPVLi.Value AND NOT xSimAct THEN 
                    BypassAct.Value := true;
                ELSIF RstBypLi.Value OR xSimAct THEN 
                    BypassAct.Value := false;
                END_IF;
            ELSE  
                IF BypPVOp AND NOT xSimAct AND NOT BypLock.Value THEN 
                    BypassAct.Value := true;
                ELSIF (RstBypOp OR xSimAct) AND NOT BypLock.Value THEN 
                    BypassAct.Value := false;
                END_IF;
            END_IF; 

           //Check if the block is in simulation.
            IF xSimAct THEN
               IF LoopClosed.Value THEN
                  PV_Out.Value := SP.Value;  // pfr. 16.dez.2009
               ELSIF SimOnLi.Value AND SimLiOp.Value THEN
                  PV_Out.Value := SimPV_Li.Value;
               ELSE
                  PV_Out.Value := SimPV;
               END_IF;
               IF SimOnLi.Value AND SimLiOp.Value THEN
                  RbkOut.Value := SimRbkLi.Value;
               ELSE
                  RbkOut.Value := SimRbk;
               END_IF;
            ELSIF BypassAct.Value AND xFeat_SubValAct THEN
                PV_Out.Value := BypPV.Value;
                RbkOut.Value := Rbk.Value;
            ELSE
               PV_Out.Value := PV.Value;
               RbkOut.Value := Rbk.Value;
            END_IF;

            //Tracking Simulation value
            SimPV := PV_Out.Value;
            SimRbk := RbkOut.Value;
            IF SimLiOp.Value THEN
                SimOn := SimOnLi.Value;
            END_IF;

            //SP_Ext/SP_Int and Automatic/Manual mode logic----------------------------------------------------

            // setpoint from OS or linked -> SP_ExtAct --------------------------------
            // Rights on switching Setpoint Intern/Extern mode are defined by SP_LiOp
            IF SP_LiOp.Value
            THEN
                // Use linked inputs to set Setpoint Intern/Extern mode
                IF xFeat_OnlyActPos
                THEN
                    IF SP_ExtLi.Value
                    THEN
                        SP_ExtAct.Value := true;
                    ELSE
                        SP_ExtAct.Value := false;
                    END_IF;
                    SP_IntLi.Value := false;
                ELSE
                    IF SP_IntLi.Value AND SP_ExtLi.Value THEN
                        ErrorNum := C_ERROR_INVALID_SIGNAL;
                        xInvalidMode := true;    
                    ELSIF SP_IntLi.Value THEN
                        SP_ExtAct.Value := false;
                    ELSIF SP_ExtLi.Value THEN
                        SP_ExtAct.Value := true;
                    END_IF;
                END_IF;
            ELSE
                // Use operator inputs to set Setpoint Intern/Extern mode
                IF SP_IntOp
                THEN
                    SP_ExtAct.Value := false;
                ELSIF SP_ExtOp
                THEN
                    SP_ExtAct.Value := true;
                END_IF;
            END_IF; // IF SP_LiOp

            // Automatic/Manual mode-----------------------------------------------------
            // Rights on switching Automatic/Manual mode are defined by ModLiOp
            IF ModLiOp.Value
            THEN
                // Use linked inputs to set Automatic/Manual mode
                IF xFeat_OnlyActPos
                THEN
                    AdvCoAct.Value:= false; // program mode terminated because operator goes to manual
                    IF AutModLi.Value
                    THEN
                        ManAct.Value := false;
                    ELSE
                        ManAct.Value := true;
                    END_IF;
                    ManModLi.Value := false;
                ELSE
                    IF ManModLi.Value AND AutModLi.Value THEN
                        ErrorNum := C_ERROR_INVALID_SIGNAL;
                        xInvalidMode := true;    
                    ELSIF ManModLi.Value THEN
                        ManAct.Value := true;
                        AdvCoAct.Value:= false; // program mode terminated because operator goes to manual
                    ELSIF AutModLi.Value THEN
                        ManAct.Value := false;
                        AdvCoAct.Value:= false; // program mode terminated because operator goes to automatic
                    END_IF;
                END_IF;
            ELSE
                // Use operator inputs to set Automatic/Manual mode
                IF ManModOp
                THEN
                    ManAct.Value := true;
                    AdvCoAct.Value:= false; // program mode terminated because operator goes to manual
                ELSIF AutModOp
                THEN
                    ManAct.Value := false;
                    AdvCoAct.Value:= false; // program mode terminated because operator goes to automatic
                END_IF;
            END_IF; // IF ModLiOp
            AutAct.Value := NOT ManAct.Value AND NOT OosAct.Value;

            //reset parameter
            SP_IntOp := false;
            SP_ExtOp := false;
            ManModOp := false;
            AutModOp := false;

            IF xFeat_ResetInLi
            THEN
                SP_IntLi.Value := false;
                SP_ExtLi.Value := false;
                ManModLi.Value := false;
                AutModLi.Value := false;
            END_IF;

            // Program mode ready
            IF AdvCoEn.value AND NOT (MV_TrkOn.Value OR MV_ForOn.Value OR OosAct.Value OR SP_RmpOn)
            THEN
               IF NOT ManAct.Value AND AdvCoModSP THEN
                  AdvCoRdy.Value:= true;  // Ready to go to program mode and read setpoint from external program
               ELSIF NOT AdvCoModSP THEN
                  AdvCoRdy.Value:= true;  // Ready to go to program mode and read MV from external program
               ELSE
                  AdvCoRdy.Value:= false;
               END_IF;
            ELSE
               AdvCoRdy.Value:= false;
            END_IF;

            IF AdvCoRdy.Value THEN
               IF AdvCoOn OR ( AdvCoMstrOn.value AND NOT SxAdvCoMstrOn) THEN // OS command on, or rising edge of master on
                  AdvCoAct.Value:= true; // program mode active
               END_IF;
               IF AdvCoAct.Value AND NOT AdvCoModSP THEN
                  ManAct.Value:= true;
               END_IF;
            ELSE
               AdvCoAct.Value:= false; // program mode terminated because not ready
            END_IF;
            IF ( NOT AdvCoMstrOn.value AND SxAdvCoMstrOn) THEN
               AdvCoAct.Value:= false; // program mode terminated by falling edge of master on
            END_IF;
            AdvCoOn:= false; // reset operator input
            SxAdvCoMstrOn:= AdvCoMstrOn.value;

            //Loop parameter
            xOpenLoop := ManAct.Value OR MV_TrkOn.Value OR MV_ForOn.Value 
                         OR (AdvCoAct.Value AND NOT AdvCoModSP) OR xIntlock_N;
            LoopClosed.Value := NOT xOpenLoop;


            //External Setpoint ---------------------------------------------------------
            rSp := SP_Ext.Value;

            //Limitation of external setpoint
            xHiAct := false;
            xLoAct := false;

            IF SP_Ext.Value <= SP_ExLoLim.Value
            THEN
                rSp := SP_ExLoLim.Value;
                xLoAct := true;
            END_IF;
            IF (SP_Ext.Value >= SP_ExHiLim.Value)
            THEN
                rSp := SP_ExHiLim.Value;
                xHiAct := true;
            END_IF;
            SP_ExtOut.Value := rSp;
            SP_ExHiAct.Value := xHiAct;
            SP_ExLoAct.Value := xLoAct;

            //Internal Setpoint ---------------------------------------------------------
            rSp := SP_Int;

            //Limit SP_Int in reject mode
            IF SP_Int < SP_InLoLim OR SP_Int > SP_InHiLim
            THEN
                rSp := SrSP_Int;
            END_IF;

            // Program mode
            IF AdvCoAct.Value AND AdvCoModSP AND NOT SP_RmpOn
            THEN
                rSp := AdvCoMV;
            END_IF;
            //Limitation SP_Int
            IF rSp < SP_InLoLim
            THEN
                rSp := SP_InLoLim;
            END_IF;
            IF rSp > SP_InHiLim
            THEN
                rSp := SP_InHiLim;
            END_IF;
            SrSP_Int := rSp;

            SP_IntOut   := SrSP_Int;
            SP_Int  := SrSP_Int;
            //Limit SP_RmpTarget in reject mode
            IF SP_RmpTarget < SP_InLoLim OR SP_RmpTarget > SP_InHiLim
            THEN
                rSpTarget := SrSP_RmpTarget;
            ELSE
                rSpTarget := SP_RmpTarget;
            END_IF;
            //Limitation SP_Target
            IF rSpTarget < SP_InLoLim
            THEN
                rSpTarget := SP_InLoLim;
            END_IF;
            IF rSpTarget > SP_InHiLim
            THEN
                rSpTarget := SP_InHiLim;
            END_IF;
            SP_RmpTarget := rSpTarget;
            
            //Linkable parameter for Gradient ramp function
            IF SP_RmpTime < 0.0 THEN SP_RmpTime := 0.0; END_IF;
            rSP_RmpTime := SP_RmpTime;
            rSP_UpRaLim := SP_UpRaLim;
            rSP_DnRaLim := SP_DnRaLim;
            IF SP_ExtAct.Value THEN
                IF SP_LiRmpTime.ST <> 16#FF THEN
                    rSP_RmpTime := SP_LiRmpTime.Value; 
                    IF rSP_RmpTime < 0.0 THEN rSP_RmpTime := 0.0; END_IF;
                    IF SP_TrkExt THEN SP_RmpTime := rSP_RmpTime; END_IF;
                END_IF;
                IF SP_LiUpRaLim.ST <> 16#FF THEN 
                    rSP_UpRaLim := SP_LiUpRaLim.Value; 
                    IF SP_TrkExt THEN SP_UpRaLim := rSP_UpRaLim; END_IF;
                END_IF;
                IF SP_LiDnRaLim.ST <> 16#FF THEN 
                    rSP_DnRaLim := SP_LiDnRaLim.Value; 
                    IF SP_TrkExt THEN SP_DnRaLim := rSP_DnRaLim; END_IF;
                END_IF;
            END_IF;
            //If feature bit11 =0 than duration mode not possible
            IF SP_RateOn AND NOT xFeatGradDuration THEN
                SP_RmpModTime := false;
            END_IF;

            // Setpoint ramping -----------------------------------------------------------
            xHiAct := false; //SP_UpRaAct.Value
            xLoAct := false; //SP_DnRaAct.Value

            //Stop ramping
            IF xOpenLoop OR SP_ExtAct.Value
            THEN
                SP_RmpOn := false;
            END_IF;

            //Timebase
            IF TimeFactor = 0 THEN                                      // Conversion to Per Second
                SrTimeFact := C_TM_PERSEC;
            ELSIF TimeFactor = 1 THEN                                   // Conversion to Per Minute
                SrTimeFact := C_TM_PERMIN;
            ELSIF TimeFactor = 2 THEN                                   // Conversion to Per Hour
                SrTimeFact := C_TM_PERHOUR;
            ELSE
                ErrorNum := C_ERROR_TM;
            END_IF;

            IF SP_RmpOn
            THEN
                SP_RateOn := false;

                //Start ramping
                IF NOT SxSP_RmpOn 
                   OR (rSpTarget <> SrSP_RmpTarget) AND xFeatRmpActStartPoint
                THEN
                    //Start with ramping
                    SrSP_StartRmp := rSp;
                    SrRestSP_Rmp := 0.0;
                    xRampRes :=  SP_RmpModTime; //true;
                END_IF;

                //Caculate grade
                IF SP_RmpModTime
                THEN
                    IF SP_RmpTime > 0.0
                    THEN
                        rGrade := (rSpTarget - SrSP_StartRmp) *SrTimeFact*rSampleTime /SP_RmpTime;
                        xRampAct := true;
                    ELSE
                        rGrade := rSpTarget - SrSP_StartRmp;
                    END_IF;
                ELSE;
                    IF (rSpTarget - SrSP_StartRmp) > 0.0
                    THEN
                        rGrade := ABS(SP_UpRaLim) *SrTimeFact*rSampleTime;
                    ELSE
                        rGrade := -ABS(SP_DnRaLim) *SrTimeFact*rSampleTime;
                    END_IF;
                END_IF;

                //Summation double precision
                rTemp1 := SrRestSP_Rmp + rGrade ;
                rSp := SP.Value + rTemp1;
                SrRestSP_Rmp := (SP.Value - rSp) + rTemp1;

                // SP_RmpTarget reached
                IF (rSp <= rSpTarget) AND (rGrade <= 0.0) OR (rSp >= rSpTarget) AND (rGrade >= 0.0)
                THEN
                    SP_RmpOn := false;
                    rSp:= rSpTarget;
                    SxSP_RmpOn := true; //Target reached in one cycle
                ELSE
                    IF rGrade >= 0.0 THEN xHiAct := true; END_IF;
                    IF rGrade <= 0.0 THEN xLoAct := true; END_IF;
                END_IF;
            END_IF; //IF SP_RmpOn
           
       
            // Switch SP Extern/Intern -----------------------------------------------------------

            IF SP_ExtAct.Value AND NOT (AdvCoAct.Value AND AdvCoModSP AND NOT SP_RmpOn)
            THEN
                rSp := SP_ExtOut.Value;
            END_IF;

            rSpDelt := rSp - SP.Value;

            //Setpoint rate limiting -----------------------------------------------------------

            IF SP_RateOn
            THEN
                SP_RmpOn := false;

                IF SP_RateTarget <> rSp THEN  
                    //Start with ramping
                    SrSP_StartRmp := SP.Value;
                    SrRestSP_Rmp := 0.0;
                    xRampRes :=  SP_RmpModTime; //true;
                END_IF;

                IF xFeatGradDuration AND SP_RmpModTime  // Time based ramping
                THEN
                    IF rSP_RmpTime > 0.0
                    THEN
                        rGrade := (rSp - SrSP_StartRmp) *SrTimeFact*rSampleTime /rSP_RmpTime;
                        xRampAct := true;
                    ELSE
                        rGrade := rSp - SrSP_StartRmp;
                    END_IF;
                ELSE;

                    IF (rSp > SrSP_StartRmp) AND (rSP_UpRaLim <> 0) THEN
                        rGrade := ABS(rSP_UpRaLim) *SrTimeFact*rSampleTime;
                    ELSIF (rSp < SrSP_StartRmp) AND (rSP_DnRaLim <> 0) THEN 
                        rGrade := -ABS(rSP_DnRaLim) *SrTimeFact*rSampleTime;
                    ELSE
                        rGrade := 0.0;
                    END_IF;

                END_IF;//IF xFeatGradDuration AND SP_RmpModTime THEN // Time based ramping

                IF (rSpDelt >= rGrade) AND (rSp > SrSP_StartRmp)
                THEN
                    xHiAct := true;
                    rSp := SP.Value + (SrRestSP_Rmp + rGrade);
                    SrRestSP_Rmp := (SP.Value - rSp) + rGrade;
                    rSpDelt := rGrade;
                END_IF;

                IF (rSpDelt <= rGrade) AND (rSp < SrSP_StartRmp)
                THEN
                    rSp := SP.Value + (SrRestSP_Rmp + rGrade);
                    SrRestSP_Rmp := (SP.Value - rSp) + rGrade;
                    xLoAct := true;
                    rSpDelt := rGrade;
                END_IF;

                IF NOT(xHiAct OR xLoAct) THEN
                    SrSP_StartRmp := rSP;
                    xRampAct := false;
                END_IF;
                    
            ELSIF NOT SP_RmpOn THEN
                SrRestSP_Rmp := 0.0;
                SrSP_StartRmp := rSp;
            END_IF; //IF SP_RateOn AND SP_ExtAct.Value
            SP_UpRaAct.Value := xHiAct; //SP_UpRaAct.Value
            SP_DnRaAct.Value := xLoAct; //SP_DnRaAct.Value

            IF SP_ExtAct.Value AND NOT (AdvCoAct.Value AND AdvCoModSP AND NOT SP_RmpOn)
            THEN
                SP_RateTarget := SP_ExtOut.Value;
            ELSE 
                SP_RateTarget := SP_IntOut;
            END_IF;

            //Remaining ramp time 
            IF xRampRes THEN 
                SP_RemRT := rSP_RmpTime/SrTimeFact - rSampleTime;
            ELSIF  xRampAct THEN

                SP_RemRT := SP_RemRT - rSampleTime;
                IF SP_RemRT <= 0.0 THEN SP_RemRT := 0.0; END_IF;  

                IF SP_RmpOn THEN 
                    rTemp1 := rSpTarget;
                ELSE
                    rTemp1 := SP_RateTarget;
                END_IF;
                IF (SrSP_RmpTarget <> rSpTarget) AND SP_RmpOn
                   OR (StcRes.SrSP_RmpTime <> rSP_RmpTime) THEN
                    SP_RemRT := (rTemp1 - rSp) / (rTemp1 - SrSP_StartRmp) * rSP_RmpTime / SrTimeFact;
                END_IF;  

            ELSE 
                SP_RemRT := 0.0;
            END_IF;

            //Save old values
            SrSP_RmpTarget := rSpTarget;
            StcRes.SrSP_RmpTime := rSP_RmpTime;

            //Setpoint tracking
            xSP_TrkPV := SP_TrkPV AND xOpenLoop;

            IF xFeatSpTrkPvNoPrio THEN
                xSP_TrkPV := xSP_TrkPV AND NOT SP_ExtAct.Value AND NOT AdvCoAct.Value;
                IF xSP_TrkPV THEN
                    rSp := PV_Out.Value;
                    //Limitation SP.Value
                    IF rSp < SP_InLoLim THEN rSp := SP_InLoLim; END_IF;
                    IF rSp > SP_InHiLim THEN rSp := SP_InHiLim; END_IF;
                END_IF;
            ELSIF xSP_TrkPV THEN
                rSp := PV_Out.Value;
            END_IF;
                
            SP.Value := rSp;
            
            //SrSP_RmpTarget := rSpTarget;
           // SxSP_RmpOn := SP_RmpOn;


            //Write back to internal setpoint
            IF xSP_TrkPV OR (SP_TrkExt AND SP_ExtAct.Value) OR SP_RmpOn OR SxSP_RmpOn OR AdvCoAct.Value
            THEN
                //Limitation
                IF rSp < SP_InLoLim
                THEN
                    rSp := SP_InLoLim;
                END_IF;
                IF rSp > SP_InHiLim
                THEN
                    rSp := SP_InHiLim;
                END_IF;
                SP_Int := rSp;
            END_IF;
            SxSP_RmpOn := SP_RmpOn;

            //Error Deadband / External Control Error -----------------------------
            IF xFeat_ER_ExternOn
            THEN
                rTemp1 := ER_Ext.Value;
            ELSE
                rTemp1 := SP.Value - PV_Out.Value;  // error variable
            END_IF;

            // DeadBand adaptation
            // Error if Feature Bit30 =1 and MV_Mean is not connected with ConPerMon
            IF xFeatDeadBandAdaption AND MV_Mean.ST = 16#78 THEN ErrorNum := C_ERROR_FB30_MVMEAN; END_IF;

            // pseude SFC with state variable PhaseDeadBand: 0: DeadBand active, 1: DeadBand deactivated, 2: settling
            CASE PhaseDeadBand OF
               0 :
                  // DeadBand active, ER inside DeadBand
                  DynDeadBand:= DeadBand;
                  IF ABS( rTemp1) > DeadBand AND xFeatDeadBandAdaption AND MV_Mean.ST <> 16#78 THEN // DeadBand is left
                     PhaseDeadBand:= 1;
                  END_IF;
               1 :
                  // DeadBand deactivated
                  DynDeadBand:= 0;
                  IF ABS( rTemp1) < DeadBand/10 THEN // PV close to SP again
                     PhaseDeadBand:= 2;
                     SettlingTimer:= 0;
                  END_IF;
               2 :
                  // DeadBand still deactivated, wait for process to settle
                  DynDeadBand:= 0;
                  SettlingTimer:= SettlingTimer + rSampleTime;
                  IF SettlingTimer > SettliTime.Value THEN // settling time passed
                     IF ABS( rTemp1) < DeadBand/10 AND SettlingTimer > SettliTime.Value*SettliFactor THEN // PV still close to SP
                        PhaseDeadBand:= 0;
                        // set MV to MV_Mean
                        I_Part := MV_Mean.Value -P_Part -rFFwd;   // code  segment from tracking mode ?? to be tested carefully
                     END_IF;
                  END_IF;
            END_CASE;

            // DeadBand application
            IF rTemp1 < - DynDeadBand
            THEN
                ER.Value := rTemp1 + DynDeadBand;
            ELSE;
                IF rTemp1 > DynDeadBand
                THEN
                    ER.Value := rTemp1 - DynDeadBand;
                ELSE;
                    ER.Value := 0.0;
                END_IF;
            END_IF;

            //Gain normalizing-----------------------------------------------------
            rTemp1:= NormPV.High - NormPV.Low;
            IF rTemp1 <> 0
            THEN
                GainEff := (NormMV.High - NormMV.Low) /rTemp1 * rGain;
            ELSE;
                //paramterizing error
                ErrorNum := C_ERROR_NORM_PV;
                GainEff := 0.0;
            END_IF;
            rErGain := ER.Value *GainEff;



            //-------------------------------------------------------------------
            // Control zone:
            // enter if |ER|>ConZone but leave only when |ER|<ConZone*0.8
            //-------------------------------------------------------------------
            rConZone := ConZone;
            IF rConZone < 0.0 THEN
                rConZone := 0.0;
                ErrorNum := C_ERROR_CONZONE;
            END_IF;

            xConzExceeded := false;

            IF rConZone <> 0.0
            THEN
                rTemp1 := rConZone*0.8;
                rTemp2 := ER.Value;
                IF( GainEff < 0.0 )  THEN
                    rTemp2 := -rTemp2;
                END_IF;
                IF (rTemp2 >= rConZone) OR (SxConzExceeded AND (rTemp2>=rTemp1))
                THEN
                    rLmn := MV_HiLim.Value;
                    xConzExceeded := true;
                ELSIF (rTemp2 <= -rConZone) OR (SxConzExceeded AND (rTemp2 <= -rTemp1))
                THEN
                    rLmn := MV_LoLim.Value;
                    xConzExceeded := true;
                END_IF;
            END_IF;
            SxConzExceeded := xConzExceeded;



            //PID-Algorithm--------------------------------------------------------


            //Proportional part------------------------------------------------------
            IF PropSel
            THEN
                P_Part := rErGain;
            ELSE;
                P_Part := 0.0;
            END_IF;


            //Integral part------------------------------------------------------
            rI_Part := I_Part;
            IF TI.Value <> 0 AND IntSel
            THEN
                IF NOT (xOpenLoop OR xConzExceeded)
                THEN
                    //I-Part caculate to Trapezregel
                    //delta I-Part
                    rDiff := SrRestInt + rSampleTime /rTi * (rErGain+SrInvOld)*0.5 ;

                    IF ((IntHoldPos.Value OR MV_HiAct.Value) AND rDiff>0.0) OR ((IntHoldNeg.Value OR MV_LoAct.Value) AND rDiff<0.0)
                    THEN
                        rDiff := 0.0;
                    END_IF;

                    //actual I-Part
                    rI_Part := I_Part + rDiff;
                    //double precision
                    SrRestInt := (I_Part - rI_Part) + rDiff;
                END_IF; //IF xOpenLoop OR xConzExceeded

            ELSE;
                rI_Part := MV_Offset;
                SrRestInt := 0.0;
            END_IF; //IF TI.Value <> 0 AND IntSel
            SrInvOld := rErGain;


            //Derivative part------------------------------------------------------------
            IF DiffToFbk
            THEN
                //D_Part in readback path
                rDiff := -PV.Value * GainEff;
            ELSE;
                rDiff := rErGain;
            END_IF;

            IF TD.Value<>0 AND NOT (xOpenLoop OR xConzExceeded)
               AND DiffToFbk = SxDiffToFbk AND NOT SxD_PartInit AND DiffSel
            THEN
                //Gain of deviation rTemp1
                rTemp1 := rTd / (rTmLag + rSampleTime*0.5);
                //Deviation output
                D_Part := (rDiff - SrRbkDev) * rTemp1;
                D_Part:= ChkREAL( In := D_Part,   ErrNum := nTemp);
                //Storing old readback value intermediately
                rTemp1 := SrRbkDev;
                //Caculate delta readback value
                rTemp2 := SrRestDif + rSampleTime/rTd * D_Part;
                //Actual readback value
                SrRbkDev := rTemp1 + rTemp2;
                //double precision
                SrRestDif := (rTemp1 - SrRbkDev) + rTemp2;
            ELSE
                D_Part := 0.0;
                SrRestDif := 0.0;
                SrRbkDev := rDiff;
                SxD_PartInit := false;
            END_IF;
            SxDiffToFbk := DiffToFbk;

            //Limit FFwd
            xHiAct := false;  //HiLim
            xLoAct := false;  //LoLim
            rFFwd := FFwd.Value;
            IF rFFwd < FFwdLoLim.Value
            THEN
                rFFwd := FFwdLoLim.Value;
                xLoAct := true;
            END_IF;
            IF rFFwd > FFwdHiLim.Value
            THEN
                rFFwd := FFwdHiLim.Value;
                xHiAct := true;
            END_IF;
            FFwdHiAct.Value := xHiAct;
            FFwdLoAct.Value := xLoAct;

            //Calculate manipulated variable--------------------------------------------

            //set ARW-Flags
            xHiAct := false;  //MV_HiLim
            xLoAct := false;  //MV_LoLim

            //Limit Man in reject mode
            rMan := Man;
            IF Man < ManLoLim OR Man > ManHiLim
            THEN
                rMan := SrMan; //Old value of Man
            END_IF;

            IF MV_ForOn.Value
            THEN
                //MV External Mode
                rLmn := MV_Forced.Value;

            ELSIF xIntlock_N AND NOT (xSimAct AND BypProt)
            THEN
                //Safe position
                rLmn := rSafePos;

            ELSE
                IF ManAct.Value AND NOT (AdvCoAct.Value AND NOT AdvCoModSP)
                THEN
                    //Manual Mode


                    //Limit Man; reject mode should realized in faceplate
                    IF rMan <= ManLoLim
                    THEN
                        rMan := ManLoLim;
                        xLoAct := true;
                    END_IF;
                    IF rMan >= ManHiLim
                    THEN
                        rMan := ManHiLim;
                        xHiAct := true;
                    END_IF;

                    rLmn := rMan;
                ELSE
                    //Automation and tracking mode
                    IF MV_TrkOn.Value
                    THEN
                        //MV Tracking Mode
                        rLmn := MV_Trk.Value;

                    // Program mode
                    ELSIF AdvCoAct.Value AND NOT AdvCoModSP
                    THEN
                        rLmn := AdvCoMV;

                    ELSE;
                        //Automatic mode--------------------------------------------------

                        // PID-Output in automatic mode

                        IF NOT xConzExceeded
                        THEN
                            rLmn := P_Part + rI_Part + D_Part + rFFwd;

                            IF TI.Value <> 0.0 AND IntSel
                            THEN

                                // compensate integrator if P part smaller for setpoint changes
                                IF PropSel
                                THEN

                                    rDiff := GainEff * ((ER.Value - rEr) + (PV_Out.Value - rPvOut)) * (rPropFacSP-1.0);
                                    rLmn := rLmn + rDiff;

                                //will be tested with RMG conditions
                                //   //Online change of LMN limits (2001-05-07)
                                //   IF NOT xConzExceeded // AND NOT SxConzExceeded
                                //   THEN
                                //       IF MV_HiLim < SrMV_HiLim AND rLmn > MV_HiLim // AND rLmn < SrMV_HiLim
                                //       THEN
                                //           rTemp1 := rLmn;
                                //           IF rLmn > SrMV_HiLim THEN
                                //               rTemp1 := SrMV_HiLim;
                                //           END_IF;
                                //           rDiff := rDiff - rTemp1 + MV_HiLim;
                                //       ELSIF MV_LoLim > SrMV_LoLim AND rLmn < MV_LoLim
                                //       THEN
                                //           rTemp1 := rLmn;
                                //           IF rLmn < SrMV_LoLim THEN
                                //               rTemp1 := SrMV_LoLim;
                                //           END_IF;
                                //           rDiff := rDiff - rTemp1 + MV_LoLim;
                                //       END_IF;
                                //   END_IF;//End of "IF NOT xConzExceeded // AND NOT SxConzExceeded"


                                    rI_Part := rI_Part + rDiff;
                                END_IF;//End of "IF PropSel"

                                // limitation of I part (wacker-hotfix)------------------------------
                                IF rI_Part>(MV_HiLim.Value -rFFwd) AND rLmn>MV_HiLim.Value AND (rLmn-D_Part)>MV_HiLim.Value
                                THEN
                                    // MIN( rI_Part -(MV_HiLim.Value -rFFwd), rLmn -MV_HiLim.Value)
                                    rTemp1:= rI_Part -(MV_HiLim.Value -rFFwd);
                                    rTemp2:= rLmn -MV_HiLim.Value;
                                    IF rTemp2 < rTemp1
                                    THEN
                                        rTemp1:= rTemp2;
                                    END_IF;

                                    rI_Part:= rI_Part - rTemp1;

                                ELSIF rI_Part<(MV_LoLim.Value -rFFwd) AND rLmn<MV_LoLim.Value AND (rLmn-D_Part)<MV_LoLim.Value
                                THEN
                                    // MAX( rI_Part -(MV_LoLim.Value -FFwd), rLmn -MV_LoLim.Value)
                                    rTemp1:= rI_Part -(MV_LoLim.Value -rFFwd);
                                    rTemp2:= rLmn -MV_LoLim.Value;
                                    IF rTemp2 > rTemp1
                                    THEN
                                        rTemp1:= rTemp2;
                                    END_IF;

                                    rI_Part:= rI_Part - rTemp1;

                                END_IF; //End of "IF rI_Part>(MV_HiLim.Value -FFwd) AND rLmn>MV_HiLim.Value AND (rLmn-D_Part)>MV_HiLim.Value"


                                //avoid oscillation at limits -------------------------------------
                                // bring back to limit if rI_Part increases more than P_Part+D_Part+FFwd
                                IF IntHoldPos.Value OR MV_HiAct.Value
                                THEN
                                    IF rLmn < MV_HiLim.Value
                                    THEN
                                        rTemp1 := rSampleTime/rTi * P_Part;

                                        IF rLmn + rTemp1 >= MV_HiLim.Value
                                        THEN
                                            rLmn := MV_HiLim.Value;
                                            rI_Part:= rI_Part +rTemp1;
                                        END_IF;
                                    END_IF;

                                ELSIF IntHoldNeg.Value OR MV_LoAct.Value
                                THEN
                                    IF rLmn > MV_LoLim.Value
                                    THEN
                                        rTemp1 := rSampleTime/rTi * P_Part;

                                        IF rLmn + rTemp1 <= MV_LoLim.Value
                                        THEN
                                            rLmn := MV_LoLim.Value;
                                            rI_Part:= rI_Part +rTemp1;
                                        END_IF;
                                    END_IF;
                                END_IF; //End of "IF IntHoldPos.Value OR MV_HiAct"

                            END_IF;//End of "IF TI.Value <> 0.0 AND IntSel"

                        END_IF; //End of "IF NOT xConzExceeded"


                    END_IF;//End of "IF MV_TrkOn"

                    //Limitation MV in automatic and tracking mode
                    IF rLmn <= MV_LoLim.Value
                    THEN
                        rLmn := MV_LoLim.Value;
                        xLoAct := true;
                    END_IF;
                    IF (rLmn >= MV_HiLim.Value)
                    THEN
                        rLmn := MV_HiLim.Value;
                        xHiAct := true;
                    END_IF;

                END_IF;//End of "IF ManAct"

            END_IF;//End of "IF MV_ForOn"
            MV_HiAct.Value := xHiAct;
            MV_LoAct.Value := xLoAct;


            //Write output and static local data -------------------------------
            MV.Value := rLmn;

            //Write back Man
            IF NOT ManAct.Value OR MV_ForOn.Value OR xIntlock_N OR AdvCoAct.Value AND NOT AdvCoModSP
            THEN
                //Limit Man
                rMan := MV.Value;
                IF rMan < ManLoLim
                THEN
                    rMan := ManLoLim;
                END_IF;
                IF rMan > ManHiLim
                THEN
                    rMan := ManHiLim;
                END_IF;
            END_IF;
            Man := rMan;
            SrMan := rMan;

            //Write back I_Part
            IF TI.Value <> 0 AND IntSel
            THEN

                IF (xOpenLoop OR xConzExceeded AND NOT xFeat_ConZoneI_MVoffset AND NOT xFeat_ConZoneI_Frozen)
                THEN
                    IF xFeat_AutWithP_Part
                    THEN
                        rI_Part := MV.Value -rFFwd;
                    ELSE
                        rI_Part := MV.Value -P_Part -rFFwd;
                    END_IF;
                    SrRestInt := 0.0;
                ELSIF NOT xOpenLoop AND xConzExceeded AND xFeat_ConZoneI_MVoffset
                THEN
                    rI_Part := MV_Offset;
                    SrRestInt := 0.0;
                ELSIF NOT xOpenLoop AND xConzExceeded AND xFeat_ConZoneI_Frozen
                THEN
                    rI_Part := I_Part;
                END_IF;

            END_IF;
            I_Part := rI_Part;

            //Write back SrDiffSp
            IF NOT PropSel OR (TI.Value = 0.0) OR NOT IntSel OR xOpenLoop OR xConzExceeded
            THEN
                SrDiffSp := 0.0;
            END_IF;

            //----End of PID_ConL, StepConL

            //Check MV
            MV.Value := ChkReal(In := MV.Value, ErrNum := nTemp);
            IF (nTemp=1 OR nTemp=3) THEN ErrorNum := C_ERROR_NUM_MV; END_IF;

            //Output of Limits
            ManHiOut.Value := ManHiLim;
            ManLoOut.Value := ManLoLim;
            SP_InHiOut.Value := SP_InHiLim;
            SP_InLoOut.Value := SP_InLoLim;

            //Cascade calculation----------------------------------------------
            //Open loop in cascade mode
            CascaCut.Value := xOpenLoop OR NOT SP_ExtAct.Value;

            //CPI caculations--------------------------------------------------
            //3-sigma band around SP
            PV_ToleHi.Value := SP.Value + 3.0 * RefStdDevIn.Value;
            PV_ToleLo.Value := SP.Value - 3.0 * RefStdDevIn.Value;

            //Units calculation----------------------------------------------
            PV_UnitOut  := PV_Unit;
            MV_UnitOut  := MV_Unit;

            //@@ Alarm calculation PV; Start ------------------------------------
            //PID_ConL, StepConL, MonA_L

            // Check AlarmDelay
            IF PV_AH_DC < 0.0 THEN PV_AH_DC := 0.0; END_IF;
            IF PV_AH_DG < 0.0 THEN PV_AH_DG := 0.0; END_IF;
            IF PV_WH_DC < 0.0 THEN PV_WH_DC := 0.0; END_IF;
            IF PV_WH_DG < 0.0 THEN PV_WH_DG := 0.0; END_IF;
            IF PV_TH_DC < 0.0 THEN PV_TH_DC := 0.0; END_IF;
            IF PV_TH_DG < 0.0 THEN PV_TH_DG := 0.0; END_IF;

            IF PV_A_DC < 0.0 THEN PV_A_DC := 0.0; END_IF;
            IF PV_A_DG < 0.0 THEN PV_A_DG := 0.0; END_IF;
            IF PV_W_DC < 0.0 THEN PV_W_DC := 0.0; END_IF;
            IF PV_W_DG < 0.0 THEN PV_W_DG := 0.0; END_IF;
            IF PV_T_DC < 0.0 THEN PV_T_DC := 0.0; END_IF;
            IF PV_T_DG < 0.0 THEN PV_T_DG := 0.0; END_IF;

            // Perform the alarm checking

            //Check if the Alarm Delay Time changed from previous cycle.
            IF xFeature_SepDelTime THEN
                IF SrPV_AH_DC <> PV_AH_DC THEN
                  IF SrPV_AH_OnTimer > 0.0 THEN SrPV_AH_OnTimer := PV_AH_DC; END_IF;
                END_IF;
                SrPV_AH_DC := PV_AH_DC;
                IF SrPV_A_DC <> PV_A_DC THEN
                    IF SrPV_AL_OnTimer > 0.0 THEN SrPV_AL_OnTimer := PV_A_DC; END_IF;
                END_IF;
                SrPV_A_DC := PV_A_DC;
            ELSE
                IF SrPV_A_DC <> PV_A_DC THEN
                    IF SrPV_AH_OnTimer > 0.0 THEN SrPV_AH_OnTimer := PV_A_DC; END_IF;
                    IF SrPV_AL_OnTimer > 0.0 THEN SrPV_AL_OnTimer := PV_A_DC; END_IF;
                END_IF;
                SrPV_A_DC := PV_A_DC;
            END_IF;

            IF xFeature_SepDelTime THEN
                IF SrPV_AH_DG <> PV_AH_DG THEN
                    IF SrPV_AH_OffTimer > 0.0 THEN SrPV_AH_OffTimer := PV_AH_DG; END_IF;
                END_IF;
                SrPV_AH_DG := PV_AH_DG;
            IF SrPV_A_DG <> PV_A_DG THEN
                    IF SrPV_AL_OffTimer > 0.0 THEN SrPV_AL_OffTimer := PV_A_DG; END_IF;
                END_IF;
                SrPV_A_DG := PV_A_DG;
            ELSE
                IF SrPV_A_DG <> PV_A_DG THEN
                    IF SrPV_AH_OffTimer > 0.0 THEN SrPV_AH_OffTimer := PV_A_DG; END_IF;
                    IF SrPV_AL_OffTimer > 0.0 THEN SrPV_AL_OffTimer := PV_A_DG; END_IF;
                END_IF;
                SrPV_A_DG := PV_A_DG;
            END_IF;

            //Check if the Warning Delay Time changed from previous cycle.
            IF xFeature_SepDelTime THEN
                IF SrPV_WH_DC <> PV_WH_DC THEN
                  IF SrPV_WH_OnTimer > 0.0 THEN SrPV_WH_OnTimer := PV_WH_DC; END_IF;
                END_IF;
                SrPV_WH_DC := PV_WH_DC;
            IF SrPV_W_DC <> PV_W_DC THEN
                    IF SrPV_WL_OnTimer > 0.0 THEN SrPV_WL_OnTimer := PV_W_DC; END_IF;
                END_IF;
                SrPV_W_DC := PV_W_DC;
            ELSE
                IF SrPV_W_DC <> PV_W_DC THEN
                    IF SrPV_WH_OnTimer > 0.0 THEN SrPV_WH_OnTimer := PV_W_DC; END_IF;
                    IF SrPV_WL_OnTimer > 0.0 THEN SrPV_WL_OnTimer := PV_W_DC; END_IF;
                END_IF;
                SrPV_W_DC := PV_W_DC;
            END_IF;

            IF xFeature_SepDelTime THEN
                IF SrPV_WH_DG <> PV_WH_DG THEN
                    IF SrPV_WH_OffTimer > 0.0 THEN SrPV_WH_OffTimer := PV_WH_DG; END_IF;
                END_IF;
                SrPV_WH_DG := PV_WH_DG;
            IF SrPV_W_DG <> PV_W_DG THEN
                    IF SrPV_WL_OffTimer > 0.0 THEN SrPV_WL_OffTimer := PV_W_DG; END_IF;
                END_IF;
                SrPV_W_DG := PV_W_DG;
            ELSE
                IF SrPV_W_DG <> PV_W_DG THEN
                    IF SrPV_WH_OffTimer > 0.0 THEN SrPV_WH_OffTimer := PV_W_DG; END_IF;
                    IF SrPV_WL_OffTimer > 0.0 THEN SrPV_WL_OffTimer := PV_W_DG; END_IF;
                END_IF;
                SrPV_W_DG := PV_W_DG;
            END_IF;

            //Check if the Tolerance Delay Time changed from previous cycle.
            IF xFeature_SepDelTime THEN
                IF SrPV_TH_DC <> PV_TH_DC THEN
                    IF SrPV_TH_OnTimer > 0.0 THEN SrPV_TH_OnTimer := PV_TH_DC; END_IF;
                END_IF;
                SrPV_TH_DC := PV_TH_DC;
                IF SrPV_T_DC <> PV_T_DC THEN
                    IF SrPV_TL_OnTimer > 0.0 THEN SrPV_TL_OnTimer := PV_T_DC; END_IF;
                END_IF;
                SrPV_T_DC := PV_T_DC;
            ELSE
                IF SrPV_T_DC <> PV_T_DC THEN
                    IF SrPV_TH_OnTimer > 0.0 THEN SrPV_TH_OnTimer := PV_T_DC; END_IF;
                    IF SrPV_TL_OnTimer > 0.0 THEN SrPV_TL_OnTimer := PV_T_DC; END_IF;
                END_IF;
                SrPV_T_DC := PV_T_DC;
            END_IF;

            IF xFeature_SepDelTime THEN
                IF SrPV_TH_DG <> PV_TH_DG THEN
                    IF SrPV_TH_OffTimer > 0.0 THEN SrPV_TH_OffTimer := PV_TH_DG; END_IF;
                END_IF;
                SrPV_TH_DG := PV_TH_DG;
                IF SrPV_T_DG <> PV_T_DG THEN
                    IF SrPV_TL_OffTimer > 0.0 THEN SrPV_TL_OffTimer := PV_T_DG; END_IF;
                END_IF;
                SrPV_T_DG := PV_T_DG;
            ELSE
                IF SrPV_T_DG <> PV_T_DG THEN
                    IF SrPV_TH_OffTimer > 0.0 THEN SrPV_TH_OffTimer := PV_T_DG; END_IF;
                    IF SrPV_TL_OffTimer > 0.0 THEN SrPV_TL_OffTimer := PV_T_DG; END_IF;
                END_IF;
                SrPV_T_DG := PV_T_DG;
            END_IF;

            //Check if the Process Value is greater than Alarm High Limit.
            strStatus3.x8  := FALSE;         //Delay of PV_AH_Act
            IF xFeature_SepDelTime THEN
                rTemp1 := PV_AH_DC;
                rTemp2 := PV_AH_DG;
            ELSE 
                rTemp1 := PV_A_DC;
                rTemp2 := PV_A_DG;
            END_IF;
            IF PV_AH_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF PV_Out.Value >= PV_AH_Lim THEN
                    SrPV_AH_OffTimer := rTemp2; //PV_AH_DG or PV_A_DG;
                    //Check delay.
                    IF (rTemp1 > 0.0) THEN //PV_AH_DC or PV_A_DC;
                        IF SrPV_AH_OnTimer <= 0 THEN
                            PV_AH_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                        ELSE
                             SrPV_AH_OnTimer := SrPV_AH_OnTimer - SampleTime;
                            strStatus3.x8 := PV_AH_MsgEn AND NOT MsgLock.Value;              //Delay of PV_AH_Act
                        END_IF;
                    ELSE        //Set Alarm High.
                        PV_AH_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                    END_IF;
                ELSE
                    SrPV_AH_OnTimer := rTemp1; //PV_AH_DC or PV_A_DC;
                    IF PV_Out.Value < (PV_AH_Lim - PV_Hyst) THEN
                        //Check delay.
                        IF (rTemp2 > 0.0) THEN //PV_AH_DG or PV_A_DG;
                            IF SrPV_AH_OffTimer <= 0 THEN
                                PV_AH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                            ELSE
                                 SrPV_AH_OffTimer := SrPV_AH_OffTimer - SampleTime;
                            END_IF;
                        ELSE        //Reset Alarm High.
                            PV_AH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                        END_IF;
                    ELSE
                        SrPV_AH_OffTimer  := rTemp2; //PV_AH_DG or PV_A_DG;
                    END_IF;
                END_IF;
            ELSE        //Not enabled so reset Alarm High
                PV_AH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                SrPV_AH_OnTimer := rTemp1;  //PV_AH_DC or PV_A_DC;
                SrPV_AH_OffTimer := rTemp2; //PV_AH_DG or PV_A_DG;
            END_IF;

            //Check if the Process Value is greater than Warning High Limit.
            IF xFeature_SepDelTime THEN
                rTemp1 := PV_WH_DC;
                rTemp2 := PV_WH_DG;
            ELSE 
                rTemp1 := PV_W_DC;
                rTemp2 := PV_W_DG;
            END_IF;
            strStatus3.x9  := FALSE;         //Delay of PV_WH_Act
            IF PV_WH_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF PV_Out.Value >= PV_WH_Lim THEN
                    SrPV_WH_OffTimer := rTemp2; //PV_WH_DG or PV_W_DG
                    //Check delay.
                    IF (rTemp1 > 0.0) THEN //PV_WH_DC or PV_W_DC
                        IF SrPV_WH_OnTimer <= 0 THEN
                            PV_WH_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                        ELSE
                             SrPV_WH_OnTimer := SrPV_WH_OnTimer - SampleTime;
                            strStatus3.x9 := PV_WH_MsgEn AND NOT MsgLock.Value;         //Delay of PV_WH_Act
                        END_IF;
                    ELSE        //Set Warning High
                        PV_WH_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                    END_IF;
                ELSE
                    SrPV_WH_OnTimer := rTemp1; //PV_WH_DC or PV_W_DC
                    IF PV_Out.Value < (PV_WH_Lim - PV_Hyst) THEN
                        //Check delay.
                        IF (rTemp2 > 0.0) THEN //PV_WH_DG or PV_W_DG
                            IF SrPV_WH_OffTimer <= 0 THEN
                                PV_WH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                            ELSE
                                 SrPV_WH_OffTimer := SrPV_WH_OffTimer - SampleTime;
                            END_IF;
                        ELSE        //Reset Warning High.
                            PV_WH_Act.Value:= xFeat_SwiPoiFalseAct; //FALSE;
                        END_IF;
                    ELSE
                        SrPV_WH_OffTimer    :=  rTemp2; //PV_WH_DG or PV_W_DG
                    END_IF;
                END_IF;
            ELSE        //Not enabled so reset Warning High
                PV_WH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                SrPV_WH_OnTimer := rTemp1; //PV_WH_DC or PV_W_DC
                SrPV_WH_OffTimer:= rTemp2; //PV_WH_DG or PV_W_DG
            END_IF;

            //Check if the Process Value is greater than Tolerance High Limit.
            strStatus3.x10  := FALSE;         //Delay of PV_TH_Act
            IF xFeature_SepDelTime THEN
                rTemp1 := PV_TH_DC;
                rTemp2 := PV_TH_DG;
            ELSE 
                rTemp1 := PV_T_DC;
                rTemp2 := PV_T_DG;
            END_IF;
            IF PV_TH_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF PV_Out.Value >= PV_TH_Lim THEN
                    SrPV_TH_OffTimer := rTemp2; //PV_TH_DG or PV_T_DG
                    //Check delay.
                    IF (rTemp1 > 0.0) THEN //PV_TH_DC or PV_T_DC
                        IF SrPV_TH_OnTimer <= 0 THEN
                            PV_TH_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                        ELSE
                             SrPV_TH_OnTimer := SrPV_TH_OnTimer - SampleTime;
                            strStatus3.x10 := PV_TH_MsgEn AND NOT MsgLock.Value;         //Delay of PV_TH_Act
                        END_IF;
                    ELSE        //Set Warning High
                        PV_TH_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                    END_IF;
                ELSE
                    SrPV_TH_OnTimer := rTemp1; //PV_TH_DC or PV_T_DC
                    IF PV_Out.Value < (PV_TH_Lim - PV_Hyst) THEN
                        //Check delay.
                        IF (rTemp2 > 0.0) THEN //PV_TH_DG or PV_T_DG
                            IF SrPV_TH_OffTimer <= 0 THEN
                                PV_TH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                            ELSE
                                 SrPV_TH_OffTimer := SrPV_TH_OffTimer - SampleTime;
                            END_IF;
                        ELSE        //Reset Warning High.
                            PV_TH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                        END_IF;
                    ELSE
                        SrPV_TH_OffTimer := rTemp2; //PV_TH_DG or PV_T_DG
                    END_IF;
                END_IF;
            ELSE        //Not enabled so reset Warning High
                PV_TH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                SrPV_TH_OnTimer := rTemp1; //PV_TH_DC or PV_T_DC
                SrPV_TH_OffTimer := rTemp2; //PV_TH_DG or PV_T_DG
            END_IF;

            //Check if the Process Value is smaller than Tolerance Low Limit.
            strStatus3.x11  := FALSE;         //Delay of PV_TL_Act
            IF PV_TL_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF PV_Out.Value <= PV_TL_Lim THEN
                    SrPV_TL_OffTimer := PV_T_DG;
                    //Check delay.
                    IF PV_T_DC > 0.0 THEN
                        IF SrPV_TL_OnTimer <= 0 THEN
                             PV_TL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                        ELSE
                             SrPV_TL_OnTimer := SrPV_TL_OnTimer - SampleTime;
                             strStatus3.x11  := PV_TL_MsgEn AND NOT MsgLock.Value;         //Delay of PV_TL_Act
                        END_IF;
                    ELSE
                        //Set the Low warning.
                        PV_TL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                    END_IF;
                ELSE
                    SrPV_TL_OnTimer := PV_T_DC;
                    IF PV_Out.Value > PV_TL_Lim + PV_Hyst THEN
                        //Check delay.
                        IF PV_T_DG > 0.0 THEN
                            IF SrPV_TL_OffTimer <= 0 THEN
                                 PV_TL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                            ELSE
                                 SrPV_TL_OffTimer := SrPV_TL_OffTimer - SampleTime;
                            END_IF;
                        ELSE
                            //Reset Warning Low .
                            PV_TL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                        END_IF;
                    ELSE
                        SrPV_TL_OffTimer := PV_T_DG;
                    END_IF;
                END_IF;
            ELSE
                //Not enabled so reset Warning Low.
                PV_TL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                SrPV_TL_OnTimer  := PV_T_DC;
                SrPV_TL_OffTimer := PV_T_DG;
            END_IF;

            //Check if the Process Value is smaller than Warning Low Limit.
            strStatus3.x12  := FALSE;         //Delay of PV_WL_Act
            IF PV_WL_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF PV_Out.Value <= PV_WL_Lim THEN
                    SrPV_WL_OffTimer := PV_W_DG;
                    //Check delay.
                    IF PV_W_DC > 0.0 THEN
                        IF SrPV_WL_OnTimer <= 0 THEN
                             PV_WL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                        ELSE
                             SrPV_WL_OnTimer := SrPV_WL_OnTimer - SampleTime;
                             strStatus3.x12  := PV_WL_MsgEn AND NOT MsgLock.Value;         //Delay of PV_WL_Act
                        END_IF;
                    ELSE
                        //Set the Low warning.
                        PV_WL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                    END_IF;
                ELSE
                    SrPV_WL_OnTimer := PV_W_DC;
                    IF PV_Out.Value > PV_WL_Lim + PV_Hyst THEN
                        //Check delay.
                        IF PV_W_DG > 0.0 THEN
                            IF SrPV_WL_OffTimer <= 0 THEN
                                 PV_WL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                            ELSE
                                 SrPV_WL_OffTimer := SrPV_WL_OffTimer - SampleTime;
                            END_IF;
                        ELSE
                            //Reset Warning Low .
                            PV_WL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                        END_IF;
                    ELSE
                        SrPV_WL_OffTimer := PV_W_DG;
                    END_IF;
                END_IF;
            ELSE
                //Not enabled so reset Warning Low.
                PV_WL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                SrPV_WL_OnTimer  := PV_W_DC;
                SrPV_WL_OffTimer := PV_W_DG;
            END_IF;

            //Check if the Process Value is smaller than Alarm Low Limit.
            strStatus3.x13  := FALSE;         //Delay of PV_AL_Act
            IF PV_AL_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF PV_Out.Value <= PV_AL_Lim THEN
                    SrPV_AL_OffTimer := PV_A_DG;
                    //Check delay.
                    IF PV_A_DC > 0.0 THEN
                        IF SrPV_AL_OnTimer <= 0 THEN
                             PV_AL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                        ELSE
                             SrPV_AL_OnTimer := SrPV_AL_OnTimer - SampleTime;
                             strStatus3.x13  := PV_AL_MsgEn AND NOT MsgLock.Value;         //Delay of PV_AL_Act
                        END_IF;
                    ELSE
                        //Set the Low Low Alarm.
                        PV_AL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                    END_IF;
                ELSE
                    SrPV_AL_OnTimer := PV_A_DC;
                    IF PV_Out.Value > PV_AL_Lim + PV_Hyst THEN
                        //Check delay.
                        IF PV_A_DG > 0.0 THEN
                            IF SrPV_AL_OffTimer <= 0 THEN
                                 PV_AL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                            ELSE
                                 SrPV_AL_OffTimer := SrPV_AL_OffTimer - SampleTime;
                            END_IF;
                        ELSE
                            //Reset Alarm Low.
                            PV_AL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                        END_IF;
                    ELSE
                        SrPV_AL_OffTimer := PV_A_DG;
                    END_IF;
                END_IF;
            ELSE
                //Not enabled so reset Alarm Low .
                PV_AL_Act.Value := xFeat_SwiPoiFalseAct; //false;
                SrPV_AL_OnTimer  := PV_A_DC;
                SrPV_AL_OffTimer := PV_A_DG;
            END_IF;

            // Example for alarm8_p call regarding the code above
            //        SIG_1:= PV_AH_Act AND PV_AH_MsgEn AND NOT MsgLock,
            //        SIG_2:= PV_WH_Act AND PV_WH_MsgEn AND NOT MsgLock,
            //        SIG_3:= PV_TH_Act AND PV_TH_MsgEn AND NOT MsgLock,
            //        SIG_4:= PV_TL_Act AND PV_TL_MsgEn AND NOT MsgLock,
            //        SIG_5:= PV_WL_Act AND PV_WL_MsgEn AND NOT MsgLock,
            //        SIG_6:= PV_AL_Act AND PV_AL_MsgEn AND NOT MsgLock,


            //@@ Alarm calculation PV End ------------------------------------

            // Alarm calculation ER

            // Check AlarmDelay
            IF ER_AH_DC < 0.0 THEN ER_AH_DC := 0.0; END_IF;
            IF ER_AH_DG < 0.0 THEN ER_AH_DG := 0.0; END_IF;
            IF ER_A_DC < 0.0 THEN ER_A_DC := 0.0; END_IF;
            IF ER_A_DG < 0.0 THEN ER_A_DG := 0.0; END_IF;

            // Check Disable Monitoring Time
            IF ER_AH_DFac < 0.0 THEN ER_AH_DFac := 0.0; END_IF;
            IF ER_AL_DFac < 0.0 THEN ER_AL_DFac := 0.0; END_IF;

            //Set Delay Timer because of SP jump
            IF xFeature_SepDelTime THEN 
                rTemp2 := ER_AH_DC; 
            ELSE 
                rTemp2 := ER_A_DC; 
            END_IF;
            IF ER_AH_DFac > 0.0 AND rSpDelt > 0.0 AND AutAct.Value THEN // pos. SP jump
                //ER_A_DCOut := MAX(ER_A_DC, ER_AH_DFac*ER)
                rTemp1 := ER_AH_DFac * rSpDelt;
                IF rTemp2 > rTemp1 THEN //rTemp2 = ER_AH_DC or ER_A_DC
                    SrER_AH_OnTimer := rTemp2;
                ELSE
                    SrER_AH_OnTimer := rTemp1;
                END_IF;
                IF xFeature_SepDelTime THEN 
                    IF ER.Value >= ER_AH_Lim THEN 
                        ER_A_DCOut := SrER_AH_OnTimer;
                    ELSE
                        ER_A_DCOut := ER_AH_DC;
                    END_IF;
                ELSE
                    ER_A_DCOut := SrER_AH_OnTimer;
                END_IF;
                    
                SxER_AH_Delay := true;
                SrER_AL_OnTimer  := ER_A_DC;
                SxER_AL_Delay := false;
            END_IF;
            IF ER_AL_DFac > 0.0 AND rSpDelt < 0.0 AND AutAct.Value THEN // neg. SP jump
                //ER_A_DCOut := MAX(ER_A_DC, -ER_AL_DFac*ER)
                rTemp1 := - ER_AL_DFac * rSpDelt;
                IF ER_A_DC > rTemp1 THEN
                    SrER_AL_OnTimer := ER_A_DC;
                ELSE
                    SrER_AL_OnTimer := rTemp1;
                END_IF;
                IF xFeature_SepDelTime THEN 
                    IF ER.Value <= ER_AL_Lim THEN 
                        ER_A_DCOut := SrER_AL_OnTimer;
                    ELSE
                        ER_A_DCOut := ER_A_DC;
                    END_IF;
                ELSE
                    ER_A_DCOut := SrER_AL_OnTimer;
                END_IF;

                SxER_AL_Delay := true;
                SrER_AH_OnTimer  := rTemp2; //rTemp2 = ER_AH_DC or ER_A_DC
                SxER_AH_Delay := false;
            END_IF;

            // Perform the alarm checking

            //Check if the Alarm Delay Time changed from previous cycle.
            IF xFeature_SepDelTime THEN
                IF SrER_AH_DC <> ER_AH_DC THEN
                    IF SrER_AH_OnTimer > 0.0 AND NOT SxER_AH_Delay THEN SrER_AH_OnTimer  := ER_AH_DC; END_IF;
                END_IF;
                SrER_AH_DC := ER_AH_DC;
                IF SrER_A_DC <> ER_A_DC THEN
                    IF SrER_AL_OnTimer > 0.0 AND NOT SxER_AL_Delay THEN SrER_AL_OnTimer  := ER_A_DC; END_IF;
                END_IF;
                SrER_A_DC := ER_A_DC;
            ELSE
                IF SrER_A_DC <> ER_A_DC THEN
                    IF SrER_AH_OnTimer > 0.0 AND NOT SxER_AH_Delay THEN SrER_AH_OnTimer  := ER_A_DC; END_IF;
                    IF SrER_AL_OnTimer > 0.0 AND NOT SxER_AL_Delay THEN SrER_AL_OnTimer  := ER_A_DC; END_IF;
                END_IF;
                SrER_A_DC := ER_A_DC;
            END_IF;

            IF xFeature_SepDelTime THEN
                IF SrER_AH_DG <> ER_AH_DG THEN
                    IF SrER_AH_OffTimer > 0.0 THEN SrER_AH_OffTimer  := ER_AH_DG; END_IF;
                END_IF;
                SrER_AH_DG := ER_AH_DG;
                IF SrER_A_DG <> ER_A_DG THEN
                    IF SrER_AL_OffTimer > 0.0 THEN SrER_AL_OffTimer  := ER_A_DG; END_IF;
                END_IF;
                SrER_A_DG := ER_A_DG;
            ELSE
                IF SrER_A_DG <> ER_A_DG THEN
                    IF SrER_AH_OffTimer > 0.0 THEN SrER_AH_OffTimer  := ER_A_DG; END_IF;
                    IF SrER_AL_OffTimer > 0.0 THEN SrER_AL_OffTimer  := ER_A_DG; END_IF;
                END_IF;
                SrER_A_DG := ER_A_DG;
            END_IF;


            //Check if the Alarm Delay Factor changed from previous cycle.
            IF SrER_AH_DFac <> ER_AH_DFac AND SxER_AH_Delay THEN
                //ER_A_DCOut := MAX(ER_A_DC, ER_AH_DFac*ER)
                rTemp1 := ER_AH_DFac * ER.Value;
                IF rTemp2 > rTemp1 THEN  //rTemp2 = ER_AH_DC or ER_A_DC
                    ER_A_DCOut := rTemp2;
                ELSE
                    ER_A_DCOut := rTemp1;
                END_IF;
                SrER_AH_OnTimer  := ER_A_DCOut;
            END_IF;
            SrER_AH_DFac := ER_AH_DFac;

            IF SrER_AL_DFac <> ER_AL_DFac AND SxER_AL_Delay THEN
                //ER_A_DCOut := MAX(ER_A_DC, ER_AL_DFac*ER)
                rTemp1 := ER_AL_DFac * ER.Value;
                IF ER_A_DC > rTemp1 THEN
                    ER_A_DCOut := ER_A_DC;
                ELSE
                    ER_A_DCOut := rTemp1;
                END_IF;
                SrER_AL_OnTimer  := ER_A_DCOut;
            END_IF;
            SrER_AL_DFac := ER_AL_DFac;

            //Check if ER is greater than Alarm High Limit.
            IF xFeature_SepDelTime THEN
                rTemp1 := ER_AH_DC;
                rTemp2 := ER_AH_DG;
            ELSE 
                rTemp1 := ER_A_DC;
                rTemp2 := ER_A_DG;
            END_IF;

            xRstER_AH_Delay := false;
            xRstER_AL_Delay := false;
            strStatus3.x14  := FALSE;         //Delay of ER_AH_Act
            IF ER_AH_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF ER.Value >= ER_AH_Lim THEN
                    SrER_AH_OffTimer := rTemp2; //ER_AH_DG or ER_A_DG
                    IF NOT SxER_AH_Delay THEN ER_A_DCOut := rTemp1; END_IF;
                    //Check delay.
                    IF rTemp1 > 0.0 THEN
                        IF SrER_AH_OnTimer <= 0 THEN
                             ER_AH_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                        ELSE
                             SrER_AH_OnTimer := SrER_AH_OnTimer - SampleTime;
                             strStatus3.x14  := ER_AH_MsgEn AND NOT MsgLock.Value;         //Delay of ER_AH_Act
                        END_IF;
                    ELSE
                        //Set Alarm High.
                        ER_AH_Act.Value := NOT xFeat_SwiPoiFalseAct; //true;
                    END_IF;
                ELSE
                    SrER_AH_OnTimer := rTemp1;
                    IF ER.Value < ER_AH_Lim - ER_Hyst THEN
                        //Check delay.
                        IF rTemp2 > 0.0 THEN //ER_AH_DG or ER_A_DG
                            IF SrER_AH_OffTimer <= 0 THEN
                                ER_AH_Act.Value := xFeat_SwiPoiFalseAct; //false;
                                xRstER_AH_Delay := true;
                            ELSE
                                 SrER_AH_OffTimer := SrER_AH_OffTimer - SampleTime;
                            END_IF;
                        ELSE
                            //Reset Alarm High.
                            ER_AH_Act.Value := xFeat_SwiPoiFalseAct; //false;
                            xRstER_AH_Delay := true;
                        END_IF;
                    ELSE
                        SrER_AH_OffTimer := rTemp2; //ER_AH_DG or ER_A_DG
                    END_IF;
                END_IF;
            ELSE
                //Not enabled so reset Alarm High
                ER_AH_Act.Value := xFeat_SwiPoiFalseAct; //false;
                xRstER_AH_Delay := true;
                SrER_AH_OffTimer := rTemp2; //ER_AH_DG or ER_A_DG
            END_IF;

            //Check if the ER is smaller than Alarm Low Limit.
            strStatus3.x15  := FALSE;         //Delay of ER_AL_Act
            IF ER_AL_En AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF ER.Value <= ER_AL_Lim THEN
                    SrER_AL_OffTimer := ER_A_DG;
                    IF NOT SxER_AL_Delay THEN ER_A_DCOut := ER_A_DC; END_IF;
                    //Check delay.
                    IF ER_A_DC > 0.0 THEN
                        IF SrER_AL_OnTimer <= 0 THEN
                             ER_AL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true
                        ELSE
                             SrER_AL_OnTimer := SrER_AL_OnTimer - SampleTime;
                             strStatus3.x15  := ER_AL_MsgEn AND NOT MsgLock.Value;         //Delay of ER_AL_Act
                        END_IF;
                    ELSE
                        //Set the Low Low Alarm.
                        ER_AL_Act.Value := NOT xFeat_SwiPoiFalseAct; //true
                    END_IF;
                ELSE
                    SrER_AL_OnTimer := ER_A_DC;
                    IF ER.Value > ER_AL_Lim + ER_Hyst THEN
                        //Check delay.
                        IF ER_A_DG > 0.0 THEN
                            IF SrER_AL_OffTimer <= 0 THEN
                                ER_AL_Act.Value := xFeat_SwiPoiFalseAct; //false
                                xRstER_AL_Delay := true;
                            ELSE
                                 SrER_AL_OffTimer := SrER_AL_OffTimer - SampleTime;
                            END_IF;
                        ELSE
                            //Reset Alarm Low.
                            ER_AL_Act.Value := xFeat_SwiPoiFalseAct; //false
                            xRstER_AL_Delay := true;
                        END_IF;
                    ELSE
                        SrER_AL_OffTimer := ER_A_DG;
                    END_IF;
                END_IF;
            ELSE
                //Not enabled so reset Alarm Low .
                ER_AL_Act.Value := xFeat_SwiPoiFalseAct; //false
                xRstER_AL_Delay := true;
                SrER_AL_OffTimer := ER_A_DG;
            END_IF;

            //reset ER Alarm Delay because of SP jump
            IF xRstER_AH_Delay AND xRstER_AL_Delay THEN
                SxER_AH_Delay := false;
                SxER_AL_Delay := false;

                IF xFeature_SepDelTime THEN
                    SrER_AH_OnTimer  := ER_AH_DC;
                    SrER_AL_OnTimer  := ER_A_DC;
                    ER_A_DCOut := 0.0;
                ELSE
                    SrER_AH_OnTimer  := ER_A_DC;
                    SrER_AL_OnTimer  := ER_A_DC;
                    ER_A_DCOut := ER_A_DC;
                END_IF;
            END_IF;

            //Collection OF message delays
            strStatus3.x16  := strStatus3.x8 OR strStatus3.x9 OR strStatus3.x10 OR
                               strStatus3.x11 OR strStatus3.x12 OR strStatus3.x13 OR
                               strStatus3.x14 OR strStatus3.x15;

            // Alarm calculation Rbk

            //Check if the Rbk Value is greater than Warning High Limit.
            IF RbkWH_En AND Rbk.ST <> 16#FF AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF RbkOut.Value >= RbkWH_Lim THEN
                    RbkWH_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                ELSE
                    IF RbkOut.Value < RbkWH_Lim - RbkHyst THEN
                        RbkWH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                    END_IF;
                END_IF;
            ELSE
                //Not enabled so reset Warning High
                RbkWH_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
            END_IF;

            //Check if the Error Value is smaller than Warning Low Limit.
            IF RbkWL_En AND Rbk.ST <> 16#FF AND NOT (MsgLock.Value AND xFeat_SwiPoiDis) THEN
                IF RbkOut.Value <= RbkWL_Lim THEN
                    RbkWL_Act.Value := NOT xFeat_SwiPoiFalseAct; //TRUE;
                ELSE
                    IF RbkOut.Value > RbkWL_Lim + RbkHyst THEN
                        RbkWL_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
                    END_IF;
                END_IF;
            ELSE
                //Not enabled so reset Warning Low .
                RbkWL_Act.Value := xFeat_SwiPoiFalseAct; //FALSE;
            END_IF;

            // Summery message
            SumMsgAct.Value := (xFeat_SwiPoiFalseAct XOR RbkWH_Act.Value) OR (xFeat_SwiPoiFalseAct XOR RbkWL_Act.Value)
                      OR (xFeat_SwiPoiFalseAct XOR PV_AH_Act.Value) OR (xFeat_SwiPoiFalseAct XOR PV_WH_Act.Value) OR (xFeat_SwiPoiFalseAct XOR PV_TH_Act.Value)
                      OR (xFeat_SwiPoiFalseAct XOR PV_TL_Act.Value) OR (xFeat_SwiPoiFalseAct XOR PV_WL_Act.Value) OR (xFeat_SwiPoiFalseAct XOR PV_AL_Act.Value)
                      OR (xFeat_SwiPoiFalseAct XOR ER_AH_Act.Value) OR (xFeat_SwiPoiFalseAct XOR ER_AL_Act.Value)
                      OR CSF.Value OR ExtMsg1.Value OR ExtMsg2.Value OR ExtMsg3.Value OR ExtMsg4.Value;


            // Status State Caculations -------------------------------------------------
            // Status State SP_Ext, SP
            SP_ExtOut.ST := SP_Ext.ST;
            SP_ExHiAct.ST := SP_ExtOut.ST;
            SP_ExLoAct.ST := SP_ExtOut.ST;
            IF SP_ExtAct.Value THEN
               SP.ST := SP_ExtOut.ST;
            ELSE
               SP.ST := 16#80;
            END_IF;

            //PV, Rbk Simulation
            IF xSimAct OR BypassAct.Value AND xFeat_SubValAct THEN
                PV_Out.ST := 16#60;
                IF xSimAct AND (Rbk.ST <> 16#FF) THEN
                   RbkOut.ST := 16#60;
                ELSE
                   RbkOut.ST := Rbk.ST;
                END_IF;
            ELSE
               PV_Out.ST := PV.ST;
               RbkOut.ST := Rbk.ST;
            END_IF;

            // Status State ER
            IF xFeat_ER_ExternOn THEN
                ER.ST := ER_Ext.ST;
            ELSE
                stcInST.b0 := PV_Out.ST;
                IF PV_Out.ST = 16#60 AND NOT xSimAct THEN stcInST.b0 := 16#80; END_IF;
                stcInST.b1 := SP.ST;
                IF SP.ST = 16#60 AND NOT xSimAct THEN stcInST.b1 := 16#80; END_IF;
                ER.ST := SelSt16(InST := stcInST, Num := 2, SelPrio := 0);
            END_IF;

            // Status State MV
            IF ManAct.Value THEN
                MV.ST := 16#80;
            ELSE
                // FB is sink if extern simulation
                stcInST.b0 := ER.ST;
                stcInST.b1 := FFwd.ST;
                IF FFwd.ST = 16#60 THEN stcInST.b1 := 16#80; END_IF;
                MV.ST := SelSt16(InST := stcInST, Num := 2, SelPrio := 0);
            END_IF;


            // evaluate quality code of I/O parameters and assign the lowest quality code to STATUSWORD----
            IF xFeat_ER_ExternOn THEN
                stcInST.b0 := ER_Ext.ST;
                stcInST.b1 := FFwd.ST;
                stcInST.b2 := RbkOut.ST;
                stcInST.b3 := MV_ChnST.ST;
                ST_Worst := SelSt16(InST := stcInST, Num := 4, SelPrio := 0);
            ELSE
                stcInST.b0 := SP.ST;
                stcInST.b1 := PV_Out.ST;
                stcInST.b2 := FFwd.ST;
                stcInST.b3 := RbkOut.ST;
                stcInST.b4 := MV_ChnST.ST;
                ST_Worst := SelSt16(InST := stcInST, Num := 5, SelPrio := 0);
            END_IF;

            //ST CPI
            PV_ToleHi.ST := RefStdDevIn.ST;
            PV_ToleLo.ST := RefStdDevIn.ST;

            //ST Alarms
            PV_AH_Act.ST := PV_Out.ST;
            PV_WH_Act.ST := PV_Out.ST;
            PV_TH_Act.ST := PV_Out.ST;
            PV_TL_Act.ST := PV_Out.ST;
            PV_WL_Act.ST := PV_Out.ST;
            PV_AL_Act.ST := PV_Out.ST;
            ER_AH_Act.ST := ER.ST;
            ER_AL_Act.ST := ER.ST;
            RbkWH_Act.ST := RbkOut.ST;
            RbkWL_Act.ST := RbkOut.ST;

            MV_HiAct.ST:= MV.ST;
            MV_LoAct.ST:= MV.ST;
            SP_UpRaAct.ST:= SP.ST;
            SP_DnRaAct.ST:= SP.ST;
            FFwdHiAct.ST := FFwd.ST;
            FFwdLoAct.ST := FFwd.ST;

            // LockAct
            LockAct.Value := xIntlock_N AND NOT (xSimAct AND BypProt);

        END_IF; //IF ErrorNum = C_ERROR_NO, IF ChkREAL(In := PV.Value, INF:=xError, NaN:=xError, Denormal:=xError)

        // Number of cycles for which all messages are suppressed
        IF SnRunUpCyc > 0 THEN
            SnRunUpCyc := SnRunUpCyc - 1;
        END_IF;

    END_IF; //IF NOT OosAct.Value AND xOB_Cycle

//____________________________________________________________________________________________________________________________________________
//
//Module 11: Alarm and Messaging

    IF xOB_Start OR SnRunUpCyc = 0 AND xOB_Cycle
    THEN

        //Set toggle for ALARM_8P instances - VV
        IF SnMsgToggle >= 1 THEN
            SnMsgToggle := 0;
        ELSE
            SnMsgToggle := 1;
        END_IF;

        IF SdwBatchID <> BatchID
        THEN

            FOR nTemp := 1 TO 32
             DO
                SarBatchName[nTemp] := 0;
            END_FOR;

            nTemp := BLKMOV (SRCBLK:= BatchName,DSTBLK:=SarBatchName);
            SdwBatchID := BatchID;  //ge?ndertes BatchID speichern
        END_IF;

        IF OosAct.Value THEN
            SbMsgEff1 := 0;
        ELSE
            //Set alarms in BOOL array - VV/WoP
            SaMsgEff1[1] := (xFeat_SwiPoiFalseAct XOR PV_AH_Act.Value) AND PV_AH_MsgEn AND NOT MsgLock.Value;
            SaMsgEff1[2] := (xFeat_SwiPoiFalseAct XOR PV_WH_Act.Value) AND PV_WH_MsgEn AND NOT MsgLock.Value;
            SaMsgEff1[3] := (xFeat_SwiPoiFalseAct XOR PV_TH_Act.Value) AND PV_TH_MsgEn AND NOT MsgLock.Value;
            SaMsgEff1[4] := (xFeat_SwiPoiFalseAct XOR PV_TL_Act.Value) AND PV_TL_MsgEn AND NOT MsgLock.Value;
            SaMsgEff1[5] := (xFeat_SwiPoiFalseAct XOR PV_WL_Act.Value) AND PV_WL_MsgEn AND NOT MsgLock.Value;
            SaMsgEff1[6] := (xFeat_SwiPoiFalseAct XOR PV_AL_Act.Value) AND PV_AL_MsgEn AND NOT MsgLock.Value;
            SaMsgEff1[7] := (xFeat_SwiPoiFalseAct XOR ER_AH_Act.Value) AND ER_AH_MsgEn AND NOT MsgLock.Value;
            SaMsgEff1[8] := (xFeat_SwiPoiFalseAct XOR ER_AL_Act.Value) AND ER_AL_MsgEn AND NOT MsgLock.Value;
            //-------------------------- VV
        END_IF;

        //Conditions for calling ALARM_8P instance - VV
        //1: After start up 'OR'
        //2: New alarm detected 'OR'
        //3: Feature bit 22 and waiting for acknowledgement.
        // IF there are two ALARM_8P instances make the call every second cycle (SnMsgToggle)
        IF (SxShowAlarm1 = true) OR (SbMsgEff1Old <> SbMsgEff1) OR
           (NOT OosAct.Value AND Feature.Bit22 = true AND SnMsgToggle = 0 AND ((MsgAckn1 AND 16#FF) <> 16#FF OR SfbALARM_8P_1.STATUS <> 0)) THEN

            //call ALARM_8P_1 to generate alarm and messages
            SfbALARM_8P_1(EN_R := true, ID := 16#EEEE, EV_ID:= MsgEvID1,
                SIG_1:= SaMsgEff1[1],   // VV/WoP
                SIG_2:= SaMsgEff1[2],   // VV/WoP
                SIG_3:= SaMsgEff1[3],   // VV/WoP
                SIG_4:= SaMsgEff1[4],   // VV/WoP
                SIG_5:= SaMsgEff1[5],   // VV/WoP
                SIG_6:= SaMsgEff1[6],   // VV/WoP
                SIG_7:= SaMsgEff1[7],   // VV/WoP
                SIG_8:= SaMsgEff1[8],   // VV/WoP
                SD_1 := SarBatchName,
                SD_2 := StepNo,
                SD_3 := BatchID,
                SD_4 := PV_Out.Value,
                SD_5 := ER.Value,
                SD_6 := ExtVa106,
                SD_7 := ExtVa107);

            //If the Feature bit is set copy ALARM_8P status to the block outputs, otherwise reset them
            //(due to one shot call of ALARM_8P the status is not actual) VV/WoP
            IF Feature.Bit22 THEN
                MsgErr1  := SfbALARM_8P_1.ERROR;
                MsgStat1 := SfbALARM_8P_1.STATUS;
                MsgAckn1 := SfbALARM_8P_1.ACK_STATE;
            ELSE
                MsgErr1 := FALSE;
                MsgStat1 := 0;
                MsgAckn1 := 0;
            END_IF;
            SbMsgEff1Old := SbMsgEff1;  //Save alarms for next cycle change detection - VV/WoP
            //Reapeat call when error - VV
            //Aufruf bei tempor?ren Fehlern wiederholen:
            //STATUS = 20: Zu wenig Arbeitsspeicher vorhanden. H-System: Aufruf des SFB w?hrend des Aufdatens
            SxShowAlarm1 := SfbALARM_8P_1.STATUS = 20;
            //Nicht ber?cksichtig werden folgende tempor?re Fehler, da sie sich auch ohne Neuaufruf beheben:
            //STATUS = 12: Instanz des SFB35 noch nicht fertig initialisiert
            //STATUS = 25: Die Kommunikation wurde angesto?en. Die Meldung ist in Bearbeitung.
        END_IF;

        IF OosAct.Value THEN
            SbMsgEff2 := 0;
        ELSE
            //Set alarms in BOOL array - VV/WoP
            SaMsgEff2[1] := ExtMsg1.Value AND NOT (MsgLock.Value AND xFeatMsgLockAll);
            SaMsgEff2[2] := ExtMsg2.Value AND NOT (MsgLock.Value AND xFeatMsgLockAll);
            SaMsgEff2[3] := ExtMsg3.Value AND NOT (MsgLock.Value AND xFeatMsgLockAll);
            SaMsgEff2[4] := ExtMsg4.Value AND NOT (MsgLock.Value AND xFeatMsgLockAll);
            SaMsgEff2[6] := CSF.Value AND NOT (MsgLock.Value AND xFeatMsgLockAll);
            SaMsgEff2[7] := (xFeat_SwiPoiFalseAct XOR RbkWH_Act.Value) AND RbkWH_MsgEn AND NOT MsgLock.Value;
            SaMsgEff2[8] := (xFeat_SwiPoiFalseAct XOR RbkWL_Act.Value) AND RbkWL_MsgEn AND NOT MsgLock.Value;
            //------------------------ VV/WoP
        END_IF;

        //Conditions for calling ALARM_8P instance - VV
        //1: After start up 'OR'
        //2: New alarm detected 'OR'
        //3: Feature bit 22 and waiting for acknowledgement.
        // IF there are two ALARM_8P instances make the call every second cycle (SnMsgToggle)
        IF (SxShowAlarm2 = true) OR (SbMsgEff2Old <> SbMsgEff2) OR
           (NOT OosAct.Value AND Feature.Bit22 = true AND SnMsgToggle = 1 AND ((MsgAckn2 AND 16#FF) <> 16#FF OR SfbALARM_8P_2.STATUS <> 0)) THEN

            //call ALARM_8P_2 to generate alarm and messages
            SfbALARM_8P_2(EN_R := true, ID := 16#EEEE, EV_ID:= MsgEvID2,
                SIG_1:= SaMsgEff2[1],   // VV/WoP
                SIG_2:= SaMsgEff2[2],   // VV/WoP
                SIG_3:= SaMsgEff2[3],   // VV/WoP
                SIG_4:= SaMsgEff2[4],   // VV/WoP
                SIG_6:= SaMsgEff2[6],   // VV/WoP
                SIG_7:= SaMsgEff2[7],   // VV/WoP
                SIG_8:= SaMsgEff2[8],   // VV/WoP
                SD_1 := SarBatchName,
                SD_2 := StepNo,
                SD_3 := BatchID,
                SD_4 := RbkOut.Value,
                SD_5 := ExtMsg1.ST,
                SD_6 := ExtMsg2.ST,
                SD_7 := ExtMsg3.ST,
                SD_8 := ExtMsg4.ST,
                SD_9 := ExtVa209,
                SD_10 := ExtVa210);

          //If the Feature bit is set copy ALARM_8P status to the block outputs, otherwise reset them
          //(due to one shot call of ALARM_8P the status is not actual) VV/WoP
          IF Feature.Bit22 THEN
              MsgErr2 := SfbALARM_8P_2.ERROR;
              MsgStat2 := SfbALARM_8P_2.STATUS;
              MsgAckn2 := SfbALARM_8P_2.ACK_STATE;
          ELSE
              MsgErr2 := FALSE;
              MsgStat2 := 0;
              MsgAckn2 := 0;
          END_IF;

          SbMsgEff2Old := SbMsgEff2;  //Save alarms for next cycle change detection - VV/WoP
          //Reapeat call when error - VV
          //Aufruf bei tempor?ren Fehlern wiederholen:
          //STATUS = 20: Zu wenig Arbeitsspeicher vorhanden. H-System: Aufruf des SFB w?hrend des Aufdatens
          SxShowAlarm2 := SfbALARM_8P_2.STATUS = 20;
          //Nicht ber?cksichtig werden folgende tempor?re Fehler, da sie sich auch ohne Neuaufruf beheben:
          //STATUS = 12: Instanz des SFB35 noch nicht fertig initialisiert
          //STATUS = 25: Die Kommunikation wurde angesto?en. Die Meldung ist in Bearbeitung.

        END_IF;

    END_IF; //IF (xOB_Start OR SnRunUpCyc = 0 AND xOB_Cycle) AND NOT OosAct.Value

//___________________________________________________________________________________________________________________________________________________
//
//Module 12: Miscellaneous

    //Module 12 only in normal cyclic operation or start up

    IF xOB_Cycle OR xOB_Start THEN

        IF NOT OosAct.Value THEN
            //Processing group error and ready to start--------------------------------------------------------------------------------------
            GrpErr.Value :=    CSF.Value
                            ;
            RdyToStart.Value :=     NOT GrpErr.Value        //no grpoup error
                                AND NOT MV_ForOn.Value      //not stafty MV value activ
                                ;
        END_IF;

        //Check that the input EventTsIn is connected. If yes copy data to the buffer.
        IF ((anyEvtTsIn.DataType = 16#02) AND (anyEvtTsIn.Repetition = C_SIZE_OF_EVT16TS)) THEN
            //There is a connection to Evt16Ts structure. Copy data from EventTs block to local variables

            //read from EventTsIn
            diOffset := DWORD_TO_DINT(anyEvtTsIn.Address AND 16#FFFFFF)/8; //diOffset now has pointer to InValAct
            wEventTsIn := WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DW[diOffset]; // Active signals 1..16 with inversion

            //write to EventTs
            EvtTs_Mode.Connected := true;
            EvtTs_Mode.MS_Release := MS_Release.Value;
            EvtTs_Mode.MsgLock := MsgLock.Value AND NOT xFeatSuppMsgLckOOS;
            EvtTs_Mode.OosAct := OosAct.Value AND NOT xFeatSuppMsgLckOOS;
            EvtTs_Mode.BatchEn := BatchEn;
            EvtTs_Mode.Occupied := Occupied;

            diOffset := diOffset + 2; //Move pointer to Mode
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DW[diOffset] := atEvtTs_Mode;

            diOffset := diOffset + 2; //Move pointer to BatchID
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DD[diOffset] := BatchID;
        
            diOffset := diOffset + 4; //Move pointer of SarBatchName
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DB[diOffset] := attempANY.S7;  //0x10
            diOffset := diOffset + 1;
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DB[diOffset] := attempANY.DataType;
            diOffset := diOffset + 1;
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DW[diOffset] := attempANY.Repetition;
            diOffset := diOffset + 2;
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DW[diOffset] := attempANY.DBNumber;
            diOffset := diOffset + 2;
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DD[diOffset] := attempANY.Address;
            
            diOffset := diOffset + 4; //Move pointer to StepNo
            WORD_TO_BLOCK_DB(anyEvtTsIn.DBNumber).DD[diOffset] := StepNo;
        
        ELSE
            wEventTsIn := 16#0000; // Active signals 1..16 with inversion
        END_IF;

        IF NOT OosAct.Value THEN
            //Status1 -------------------------------------------------------------------------------------
            strStatus1.x0  := Occupied;
            strStatus1.x1  := BatchEn;
            strStatus1.x2  := xSimAct;

            strStatus1.x6  := xInvalidMode; //Set information of invalid command

            strStatus1.x8  := SP_ExtAct.Value;
            strStatus1.x9  := MV_ForOn.Value;
            strStatus1.x10 := MV_TrkOn.Value AND NOT (ManAct.Value OR MV_ForOn.Value);
            strStatus1.x11 := MV.Value > ManLoLim;
            strStatus1.x12 := SimLiOp.Value;

            strStatus1.x13 := xIntl_En;                               //Set Intl_En
            strStatus1.x14 := xIntlock_N;                             //Set Intlock

            IF SimOn AND ManAct.Value AND NOT SimLiOp.Value THEN
                strStatus1.x18 := true;  // 1= Operator can manipulate PV, GK: 15.01.2010
            ELSE
                strStatus1.x18 := false;
            END_IF;

            strStatus1.x19 := AdvCoAct.Value;
            strStatus1.x21 := NegGain.Value;
            strStatus1.x22 := (SP_UpRaAct.Value OR SP_DnRaAct.Value) AND SP_RateOn OR SP_RmpOn;
            strStatus1.x23 := OptimEn;
            strStatus1.x24 := OptimOcc;
            strStatus1.x25 := MV_TrkOn.Value;
            strStatus1.x26 := BypassAct.Value AND ((ST_Worst = 16#80) OR xFeat_SubValAct);
            strStatus1.x27 := AdvCoModSP;

            strStatus1.x29 := BypProt AND xSimAct OR MV_ForOn.Value;  //Cross pad protection inputs

            IF PhaseDeadBand > 0 THEN
               strStatus1.x30 := true;  // DeadBand temporarely deactivated
            ELSE
               strStatus1.x30 := false; // DynDeadBand:= DeadBand
            END_IF;

            IF xFeatBypass THEN
                strStatus1.x31 := Intl_En AND StcDigValIntlock.Bypass;   // Bypass Activation on QC in BlockIcon
            ELSE
                strStatus1.x31 := Intlock.Value AND Intl_En AND Intlock.ST = 16#60;   // Bypass Activation on QC in BlockIcon
            END_IF;

            //Status2 -------------------------------------------------------------------------------------

            strStatus2.x0  := MsgLock.Value;

            strStatus2.x7  := PV_AH_En OR xFeat_LimitsDisabled;
            strStatus2.x8  := PV_WH_En OR xFeat_LimitsDisabled;
            strStatus2.x9  := PV_TH_En OR xFeat_LimitsDisabled;
            strStatus2.x10 := PV_TL_En OR xFeat_LimitsDisabled;
            strStatus2.x11 := PV_WL_En OR xFeat_LimitsDisabled;
            strStatus2.x12 := PV_AL_En OR xFeat_LimitsDisabled;
            strStatus2.x13 := PV_AH_MsgEn;
            strStatus2.x14 := PV_WH_MsgEn;
            strStatus2.x15 := PV_TH_MsgEn;
            strStatus2.x16 := PV_TL_MsgEn;
            strStatus2.x17 := PV_WL_MsgEn;
            strStatus2.x18 := PV_AL_MsgEn;

            strStatus2.x21 := ER_AH_En OR xFeat_LimitsDisabled;
            strStatus2.x22 := ER_AL_En OR xFeat_LimitsDisabled;
            strStatus2.x23 := ER_AH_MsgEn AND NOT SxER_AH_Delay;
            strStatus2.x24 := ER_AL_MsgEn AND NOT SxER_AL_Delay;

            strStatus2.x27 := RbkWH_En OR xFeat_LimitsDisabled;
            strStatus2.x28 := RbkWL_En OR xFeat_LimitsDisabled;
            strStatus2.x29 := RbkWH_MsgEn;
            strStatus2.x30 := RbkWL_MsgEn;

            //Status3 -------------------------------------------------------------------------------------
            arbyStatusWord3[3] := arrbyEventTsIn[1]; // Effective signal 0..7 of the message block connected via Event16TsIn
            //Status word 4 - VV
            arbyStatusWord4[3] := arrbyEventTsIn[0]; // Effective signal 8..15 of the message block connected via Event16TsIn

            strStatus3.x17 := BypassAct.Value;

            strStatus3.x24 := xFeatBypass;
            strStatus3.x25 := StcDigValIntlock.Bypass;
            strStatus3.x26 := LockAct.Value;

            strStatus3.x27 := (SP_UpRaAct.Value OR SP_DnRaAct.Value) AND SP_RateOn;
            strStatus3.x28 := GrpErr.Value;
            strStatus3.x29 := RdyToStart.Value;

            strStatus3.x30:= NOT (MV_ChnST.ST = 16#FF); //MV_ChnST is connected
        ELSE
            dwStatus1 := 16#0;
            dwStatus2 := 16#0;
            dwStatus3 := dwStatus3 AND 16#40000000; //reset excluding BIT30
            dwStatus4 := 16#0;
        END_IF;
        strStatus1.x3  := OosAct.Value;
        strStatus1.x4  := OosLi.Value;
        strStatus1.x5  := AutAct.Value;
        strStatus1.x7  := ManAct.Value;
        strStatus1.x20 := RbkOut.ST = 16#FF;

        strStatus2.x1  := PV_AH_Act.Value;
        strStatus2.x2  := PV_WH_Act.Value;
        strStatus2.x3  := PV_TH_Act.Value;
        strStatus2.x4  := PV_TL_Act.Value;
        strStatus2.x5  := PV_WL_Act.Value;
        strStatus2.x6  := PV_AL_Act.Value;
        strStatus2.x19 := ER_AH_Act.Value;
        strStatus2.x20 := ER_AL_Act.Value;
        strStatus2.x25 := RbkWH_Act.Value;
        strStatus2.x26 := RbkWL_Act.Value;

        strStatus2.x31 := MS_RelOp;

        Status1 := dwStatus1;
        Status2 := dwStatus2;
        Status3 := dwStatus3;
        Status4 := dwStatus4;

        //OS permitions ---------------------------------------------------------------------

        //OS_PermOut
        //Change High Low WORD AND High Low BYTE
        arrdwOS_Perm[3] := ArrOS_Perm[0];
        arrdwOS_Perm[2] := ArrOS_Perm[1];
        arrdwOS_Perm[1] := ArrOS_Perm[2];
        arrdwOS_Perm[0] := ArrOS_Perm[3];
        OS_PermOut := dwOS_Perm;

        //OS_PermLog
        IF xOB_Start THEN //Out of Service mode
            OS_PermLog := 16#0;
        ELSIF OosAct.Value THEN //Out of Service mode
            OptimEn := false;
            OS_PermLog := (16#2 AND OS_PermOut);
        ELSE
            // Mode switching
            IF (NOT ManAct.Value AND NOT AdvCoAct.Value) OR ModLiOp.Value
            THEN
                stcdwOS_Perm.Bit0 :=0; // 1= Operator can switch into automatic mode
            END_IF;
            IF (ManAct.Value AND NOT AdvCoAct.Value) OR ModLiOp.Value
            THEN
                stcdwOS_Perm.Bit1 :=0; // 1= Operator can switch into manual mode
            END_IF;
            IF NOT ManAct.Value OR AdvCoAct.Value OR ModLiOp.Value
            THEN
                stcdwOS_Perm.Bit2 :=0; // 1 = Operator can switch into "out of service" mode OosOp
            END_IF;
            IF AdvCoAct.Value OR NOT AdvCoRdy.Value OR ModLiOp.Value
            THEN
                stcdwOS_Perm.Bit3 :=0; // 1 = Operator can switch into program mode AdvCoOn
            END_IF;

            IF SP_ExtAct.Value OR SP_LiOp.Value
            THEN
                stcdwOS_Perm.Bit4 :=0; // 1 = Operator can switch the setpoint to external SP_ExtOp
            END_IF;
            IF NOT SP_ExtAct.Value OR SP_LiOp.Value
            THEN
                stcdwOS_Perm.Bit5 :=0; // 1 = Operator can switch the setpoint to internal SP_IntOp
            END_IF;

            IF SP_ExtAct.Value OR (ManAct.Value AND SP_TrkPV) OR (NOT SP_ExtAct.Value AND SP_RmpOn) OR AdvCoAct.Value
            THEN
                stcdwOS_Perm.Bit6 :=0; // 1= Operator can change the setpoint
            END_IF;
            IF (NOT ManAct.Value OR MV_ForOn.Value OR AdvCoAct.Value OR LockAct.Value)
            THEN
                stcdwOS_Perm.Bit7 :=0; // 1 = Operator can change the manual parameter Man
            END_IF;

            // Ramp operations
            IF SP_RmpOn THEN
                stcdwOS_Perm.Bit12 := false; // 1= Operator can use the setpoint's gradient limitation funct. SP_RateOn
                stcdwOS_Perm.Bit13 := false; // 1= Operator can change the setpoint's upward rate limit SP_UpRaLim
                stcdwOS_Perm.Bit14 := false; // 1= Operator can change the setpoint's downward rate limit SP_DnRaLim
                stcdwOS_Perm.Bit15 := false; // 1= Operator can change ramp mode (time or gradient value) SP_RmpModTime
                stcdwOS_Perm.Bit16 := false; // 1= Operator can change the ramp time SP_RmpTime
                stcdwOS_Perm.Bit17 := true;  // 1= Operator can change the target setpoint in ramp function SP_RmpTarget
            END_IF;
            IF SP_RateOn OR SP_ExtAct.Value OR ManAct.Value OR AdvCoAct.Value
            THEN
                stcdwOS_Perm.Bit18 :=0; // 1 = Operator can activate the setpoint ramp function SP_RmpOn
            END_IF;

            IF SP_RateOn AND SP_ExtAct.Value THEN
                IF SP_LiUpRaLim.ST <> 16#FF THEN
                    stcdwOS_Perm.Bit13 := false; // 1= Operator can change the setpoint's upward rate limit SP_UpRaLim
                END_IF;
                IF SP_LiDnRaLim.ST  <> 16#FF THEN
                    stcdwOS_Perm.Bit14 := false; // 1= Operator can change the setpoint's downward rate limit SP_DnRaLim
                END_IF;
                IF SP_LiRmpTime.ST <> 16#FF THEN
                    stcdwOS_Perm.Bit16 := false; // 1= Operator can change the ramp time SP_RmpTime
                END_IF;
            END_IF;

            //If feature bit11 =0 than duration mode not possible
            IF SP_RateOn AND NOT xFeatGradDuration THEN
                stcdwOS_Perm.Bit15 := false; // 1= Operator can change ramp mode (time or gradient value) SP_RmpModTime
            END_IF;

            IF OptimEn
            THEN
                //special case PID tuning
                stcdwOS_Perm.Bit2 :=0; // 1= Operator can switch into out of service mode
                stcdwOS_Perm.Bit3 :=0; // 1= Operator enabled to switch to program mode
                stcdwOS_Perm.Bit4 :=0; // 1= Operator can switch the setpoint to external
                stcdwOS_Perm.Bit5 :=0; // 1= Operator can switch the setpoint to internal
                stcdwOS_Perm.Bit6 :=0; // 1= Operator can change the setpoint
                stcdwOS_Perm.Bit7 :=0; // 1= Operator can change the manipulated value
                stcdwOS_Perm.Bit15 :=0; // 1= Operator can switch between time and rate of change values
                stcdwOS_Perm.Bit18 :=0; // 1= Operator can activate the setpoint ramp function
                stcdwOS_Perm.Bit22 :=0; // 1= Operator can change the gain parameter
                stcdwOS_Perm.Bit23 :=0; // 1= Operator can change the integral action time parameter
                stcdwOS_Perm.Bit24 :=0; // 1= Operator can change the derivative action time parameter
                stcdwOS_Perm.Bit25 :=0; // 1= Operator can change the derivative gain parameter
                stcdwOS_Perm.Bit26 :=0; // 1= Operator can change the deadband parameter
                stcdwOS_Perm.Bit27 :=0; // 1= Operator can change the control zone parameter
            END_IF;


            //PID parameter
            IF Gain.ST <> 16#FF THEN
                stcdwOS_Perm.Bit22 := false; // 1= Operator can change the gain parameter Gain
            END_IF;
            IF TI.ST <> 16#FF THEN
                stcdwOS_Perm.Bit23 := false; // 1= Operator can change the integral time parameter TI
            END_IF;
            IF TD.ST <> 16#FF THEN
                stcdwOS_Perm.Bit24 := false; // 1= Operator can change the derivative time parameter TD
            END_IF;

            //Change High Low Word and High Low Byte
            OS_PermLog := dwOS_Perm;
        END_IF;

        //OS1PermOut
        //Change High Low WORD AND High Low BYTE
        arrdwOS_Perm[3] := ArrOS1Perm[0];
        arrdwOS_Perm[2] := ArrOS1Perm[1];
        arrdwOS_Perm[1] := ArrOS1Perm[2];
        arrdwOS_Perm[0] := ArrOS1Perm[3];
        OS1PermOut := dwOS_Perm;

        //OS1PermLog
        IF xOB_Start THEN //Out of Service mode
            OS1PermLog := 16#0;
        ELSIF  OosAct.Value
        THEN
            OS1PermLog := (16#20000 AND OS1PermOut);
        ELSE

            //Bypass
            IF xSimAct OR BypassAct.Value OR BypLiOp.Value OR BypLock.Value THEN
                stcdwOS_Perm.Bit14 := false; // 1 = Operator can activate bypass functionality 
            END_IF;
            IF xSimAct OR NOT BypassAct.Value OR BypLiOp.Value OR BypLock.Value THEN
                stcdwOS_Perm.Bit15 := false; // 1 = Operator can deactivate bypass functionality 
            END_IF;

            IF SimLiOp.Value THEN
                stcdwOS_Perm.Bit16 := false; // 1 = Operator can activate the simulation function SimOn
            END_IF;
            IF SimLiOp.Value OR NOT SimLiOp.Value AND NOT SimOn OR NOT ManAct.Value THEN
                stcdwOS_Perm.Bit28 := false; // 1 = Operator can change the simulation value SimPV
            END_IF;
            IF SimLiOp.Value OR NOT SimLiOp.Value AND NOT SimOn THEN
                stcdwOS_Perm.Bit29 := false; // 1 = Operator can change the simulation value SimRbk
            END_IF;

            IF NOT ManAct.Value OR MV_ForOn.Value THEN
                stcdwOS_Perm.Bit17 := false; // 1= Operator can activate the maintenance release function MS_RelOp
            END_IF;
                     
            stcdwOS_Perm.Bit0   := xOS1_Perm_PV_AH_Lim AND PV_AH_En;
            stcdwOS_Perm.Bit1   := xOS1_Perm_PV_WH_Lim AND PV_WH_En;
            stcdwOS_Perm.Bit2   := xOS1_Perm_PV_TH_Lim AND PV_TH_En;
            stcdwOS_Perm.Bit4   := xOS1_Perm_PV_TL_Lim AND PV_TL_En;
            stcdwOS_Perm.Bit5   := xOS1_Perm_PV_WL_Lim AND PV_WL_En;
            stcdwOS_Perm.Bit6   := xOS1_Perm_PV_AL_Lim AND PV_AL_En;
            stcdwOS_Perm.Bit7   := xOS1_Perm_ER_AH_Lim AND ER_AH_En;
            stcdwOS_Perm.Bit9   := xOS1_Perm_ER_AL_Lim AND ER_AL_En;
            stcdwOS_Perm.Bit10  := xOS1_Perm_RBK_WH_Lim AND RBKWH_En;
            stcdwOS_Perm.Bit12  := xOS1_Perm_RBK_WL_Lim AND RBKWL_En;
            stcdwOS_Perm.Bit3   := xOS1_Perm_PV_Hyst AND (PV_AH_En OR PV_WH_En
                                   OR PV_TH_En OR PV_TL_En OR PV_WL_En OR PV_AL_En);
            stcdwOS_Perm.Bit8   := xOS1_Perm_ER_Hyst AND (ER_AH_En OR ER_AL_En);
            stcdwOS_Perm.Bit11  := xOS1_Perm_RbkHyst AND (RBKWH_En OR RBKWL_En);

            
            OS1PermLog := dwOS_Perm;
        END_IF;

        // copy input paramters to output
        PV_HysOut  := PV_Hyst;
        PV_AH_Out  := PV_AH_Lim;
        PV_WH_Out  := PV_WH_Lim;
        PV_TH_Out  := PV_TH_Lim;
        PV_TL_Out  := PV_TL_Lim;
        PV_WL_Out  := PV_WL_Lim;
        PV_AL_Out  := PV_AL_Lim;

        //reset parameter
        ManModOp := false;
        OosOp := false;

        BypPVOp  :=  FALSE;  //Select bypass PV
        RstBypOp  :=  FALSE;  //Reset bypass PV

        IF xFeat_ResetInLi
        THEN
            ManModLi.Value := false;
        END_IF;

        //Set Hidden Bypass
        StcAnaValPV_Out.Bypass := BypassAct.Value;
        StcDigValPV_AH_Act.Bypass := BypassAct.Value;
        StcDigValPV_WH_Act.Bypass := BypassAct.Value;
        StcDigValPV_TH_Act.Bypass := BypassAct.Value;
        StcDigValPV_AL_Act.Bypass := BypassAct.Value;
        StcDigValPV_WL_Act.Bypass := BypassAct.Value;
        StcDigValPV_TL_Act.Bypass := BypassAct.Value;
        StcDigValER_AH_Act.Bypass := BypassAct.Value;
        StcDigValER_AL_Act.Bypass := BypassAct.Value;

    END_IF; //IF xOB_Cycle OR xOB_Start THEN  End Module 12

END_FUNCTION_BLOCK

